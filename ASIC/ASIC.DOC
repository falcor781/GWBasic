


     +--------------------------------------------------------------------+
     |                                                                    |
     |                            A S I C (tm) 5.00                       |
     |                           "Its Almost Basic"                       |
     |                                                                    |
     |                           Copyright (c) 1994                       |
     |                                   by                               |
     |                             80/20 Software                         |
     |                          All Rights Reserved                       |
     +--------------------------------------------------------------------+
     |  ASIC 5.00 is provided as shareware.  Under the shareware          |
     |  concept,  you can test a program before you buy it. If you find   |
     |  it suitable for your needs and make use of this program, you are  |
     |  expected to register it.                                          |
     |                                                                    |
     |  Feel free to distribute this software to others.  However, you    |
     |  may not charge for the distribution of this software to others    |
     |  nor may you alter the software or this documentation.             |
     |                                                                    |
     |  Registered users of any version of ASIC will receive a diskette   |
     |  containing the current version of ASIC, plus may purchase future  |
     |  updates at half of the normal registration price.  A printed      |
     |  manual is available to registered users for an additional fee.    |
     |                                                                    |
     |  For further ordering information, please see the file ORDER.FRM,  |
     |  included with ASIC.                                               |
     +--------------------------------------------------------------------+
     |                                                                    |
     |     Please send registration fees and suggestions to:              |
     |                                                                    |
     |                     80/20 Software                                 |
     |                     P.O. Box 2952                                  |
     |                     Raleigh, NC  27602-2952                        |
     |                                                                    |
     |     (Please mention the version of ASIC in any correspondence)     |
     |                                                                    |
     +--------------------------------------------------------------------+
     |    You can also send questions/comments on GEnie and Compuserve    |
     |     via EMAIL:                                                     |
     |         Compuserve                  73065,1302                     |
     |         Compuserve (via Internet)   73065.1302@compuserve.com      |
     |         GEnie                       DVISTI                         |
     |                                                                    |
     +--------------------------------------------------------------------+
     |                                                                    |
     |  DISCLAIMER:  This software is provided "as is" without warranty   |
     |  of any kind, either expressed or implied.                         |
     |                                                                    |
     |  Your registration fee entitles you to use this software on a      |
     |  single computer.  Site licenses are available, write for details. |
     |                                                                    |
     |  ASIC is a trademark of 80/20 Software                             |
     +--------------------------------------------------------------------+



                                       A S I C
                                  Table of Contents

       Chapter Title

          1.   Getting Started                              Page 6
                    Introduction                            Page 6
                    Installation                            Page 7
          2.   Tutorial                                     Page 8
          3.   Integrated Editor/Compiler Environment       Page 15
                    Introduction                            Page 15
                    ASIC Screen Contents                    Page 15
                    Menu Bar Processing                     Page 15
                    Mouse Usage                             Page 16
                    Editor Command Line Options             Page 17
                         File Name                          Page 17
                         /MONO                              Page 17
                         /NOMOUSE                           Page 17
                    Getting Help                            Page 17
                         Menu Help                          Page 17
                         Keyword Help                       Page 18
                    File Menu                               Page 18
                         New                                Page 18
                         Open                               Page 18
                         Convert                            Page 19
                         coMments include                   Page 19
                         Warnings include                   Page 19
                         Errors Include                     Page 19
                         DOS Shell                          Page 19
                         Save                               Page 19
                         Save As                            Page 20
                         auto Indent                        Page 20
                         eXit                               Page 20
                    Edit Menu                               Page 20
                         Begin Block                        Page 20
                         End Block                          Page 21
                         Search                             Page 21
                         Replace                            Page 21
                         Delete Block                       Page 21
                         Move Block                         Page 21
                         Copy Block                         Page 22
                         Search Again                       Page 22
                    Compile Menu                            Page 22
                         Compile Program                    Page 22
                         Full Program Listing               Page 22
                         Printer Output                     Page 22
                         Symbol Table                       Page 23
                         Extended Math                      Page 23
                         Decimal Math                       Page 23
                         Debugging Code                     Page 24
                         View Compile Errors                Page 24
                         Write Options To Disk              Page 24

                                      Page - 1


                            Table of Contents (Continued)

       Chapter Title

          3.   Integrated Editor/Compiler Environment (Continued)

                    Advanced Options Sub-Menu               Page 24
                         COM Output File                    Page 25
                         EXE Output File                    Page 25
                         OBJ Output File                    Page 26
                         Stack Size                         Page 26
                         Object Names                       Page 27
                         Library Names                      Page 27
                         LINK.EXE Path                      Page 27
                    Run Menu                                Page 28
                         Run Your Program                   Page 28
                         Breakpoint Toggle                  Page 28
                         Trace                              Page 29
                         Modify Variable                    Page 29
                         Watch Variable                     Page 29
                         Unwatch Variable                   Page 30
                         Abort Execution                    Page 30
                         Clear All Break/Watch              Page 30
                         Program Arguments                  Page 30
                         Swap To User Screen                Page 30
                    Help Menu                               Page 31
                         General Help                       Page 31
                         Keyword Index                      Page 31
                         ASCII Chart                        Page 31
                         aBout ASIC                         Page 31
                    Status Line                             Page 31
                    Edit Window                             Page 32
                    Keyboard Usage                          Page 32
          4    Using the Debugger                           Page 35
                    Introduction                            Page 35
                    Debugger Tutorial                       Page 35
                    Debugger Tips                           Page 41
          5.   Command-Line Compiler Options                Page 43
                    Command Line Syntax                     Page 43
                    Compiler Options                        Page 43
                    Compiler Examples                       Page 47
                    Program Project File                    Page 48
          6.   Language Elements                            Page 49
                    Character Set                           Page 49
                    Constants, Variables, and Labels        Page 50
                    Variables vs. Constants                 Page 53
                    Conversion Between Numeric Formats      Page 54
          7.   Keyword Reference                            Page 56
                    ABS                                     Page 56
                    ASC                                     Page 56
                    BEEP                                    Page 57
                    BLOAD                                   Page 58
                    BSAVE                                   Page 59

                                      Page - 2


                            Table of Contents (Continued)

       Chapter Title

                    CALL                                    Page 60
                    CHDIR                                   Page 64
                    CHR$                                    Page 64
                    CLOSE                                   Page 65
                    CLS                                     Page 65
                    CODE                                    Page 66
                    COLOR                                   Page 67
                    COMMAND$                                Page 68
                    COMSTAT                                 Page 69
                    CSRLIN                                  Page 70
                    DATA                                    Page 71
                    DATE$                                   Page 72
                    DEFSEG                                  Page 72
                    DIM                                     Page 73
                    END                                     Page 73
                    ENVIRON$                                Page 74
                    FILELEN                                 Page 74
                    FILEPOS                                 Page 75
                    FIND                                    Page 77
                    FOR/NEXT                                Page 79
                    GETDIR                                  Page 81
                    GETDRIVE                                Page 81
                    GETREGS                                 Page 82
                    GOSUB                                   Page 82
                    GOTO                                    Page 83
                    IF/THEN/ELSE/ENDIF                      Page 84
                    INKEY$                                  Page 86
                    INP                                     Page 86
                    INPUT                                   Page 87
                    INPUT#                                  Page 89
                    INSTR                                   Page 92
                    INT86                                   Page 93
                    KILL                                    Page 95
                    LCASE$                                  Page 95
                    LEFT$                                   Page 96
                    LEN                                     Page 96
                    LOCATE                                  Page 97
                    LPRINT                                  Page 97
                    LTRIM$                                  Page 98
                    MID$                                    Page 98
                    MKDIR                                   Page 99
                    MOD                                     Page 99
                    NAME                                    Page 100
                    OPEN                                    Page 101
                    OPENCOM                                 Page 102
                    OUT                                     Page 103
                    PEEK                                    Page 103



                                      Page - 3


                            Table of Contents (Continued)

       Chapter Title

                    POINT                                   Page 104
                    POKE                                    Page 105
                    POS                                     Page 106
                    PRESET                                  Page 106
                    PRINT                                   Page 107
                    PRINT#                                  Page 108
                    PSET                                    Page 110
                    RANDOMIZE                               Page 110
                    READ                                    Page 111
                    RECEIVE                                 Page 112
                    REM                                     Page 113
                    RESTORE                                 Page 113
                    RETURN                                  Page 114
                    RIGHT$                                  Page 114
                    RMDIR                                   Page 115
                    RND                                     Page 116
                    RTRIM$                                  Page 117
                    RUN                                     Page 118
                    SCREEN                                  Page 120
                    SEND                                    Page 121
                    SETREGS                                 Page 122
                    SOUND                                   Page 123
                    SPACE$                                  Page 123
                    STR$                                    Page 124
                    STRING$                                 Page 124
                    SUB/ENDSUB                              Page 125
                    TIME$                                   Page 128
                    TIMER                                   Page 129
                    UCASE$                                  Page 130
                    VAL                                     Page 130
                    VARPTR                                  Page 131
                    WHILE/WEND                              Page 131
                    WIDTH                                   Page 132
                    ZBIT                                    Page 132
                    ZMODE                                   Page 133
          8.   Compatibility with BASICA/GWBASIC            Page 134
          9.   Technical Details/Tips                       Page 136
                    Compiler Limits                         Page 136
                    Compiler Operation                      Page 136
                    Memory Optimization                     Page 138
                    Performance Optimization                Page 139
                    Debugger Limits                         Page 139
                    Debugger Operation                      Page 139
                    Debugger Overhead                       Page 140
                    BAS2ASI Operation                       Page 140
                    Storage Formats                         Page 140
                    Memory Map - COM File                   Page 143



                                      Page - 4


                            Table of Contents (Continued)

       Chapter Title

                    Memory Map - EXE File                   Page 144
          10.  Multiple Object Module Programs              Page 146
                    Overview                                Page 146
                    ASIC Subroutines                        Page 146
                    Assembler Subroutines                   Page 146
                    Building Programs With Mult OBJ Files   Page 146
                    ASIC Sample Files                       Page 146
                    Assembler Sample Files                  Page 147
                    Building the ASIC Subroutine Samples    Page 147
                    Building the Assembler Subrout Samples  Page 148
                    Assembly Language Subroutine Overview   Page 149
                    Developing Assembler Subroutines        Page 150
                    Assembling Your Subroutine              Page 151
                    Developing the Calling ASIC Program     Page 151
                    Building the Executable Program         Page 151
                    Other Link Options                      Page 151
                    Debugging                               Page 152
          11.  Converting GWBASIC Programs to ASIC Format   Page 153
                    Overview                                Page 153
                    Converting In The Integrated Environ    Page 153
                    Converting From the Command Line        Page 153
                         NOCOMMENTS option                  Page 154
                         NOERRORS option                    Page 154
                         NOWARNINGS option                  Page 154
                    Conversion Tips                         Page 154
                    Pre-conversion Tips                     Page 155
                    Post-conversion Tips                    Page 155
                    Error Messages                          Page 155
                    Warning Messages                        Page 155
                    Syntax Errors                           Page 155
                    Statement Optimization                  Page 156
                    BAS2ASI Limits                          Page 156
          12.  Error Messages                               Page 158
                    Compiler Errors                         Page 158
                    Fatal Errors                            Page 158
                    Non-Fatal Warnings                      Page 164
                    Run Time Errors                         Page 167
                    System ERROR Code Values                Page 168












                                      Page - 5


                                       A S I C

                                      Chapter 1

                                   Getting Started


                                    INTRODUCTION

     Welcome to ASIC!

     ASIC is a "BASIC" programming language compiler for IBM PCs and
     compatibles.  It includes an integrated full screen editor, from which you
     can edit, compile, and debug your programs.  Or, at your option, you can
     use your own text editor, and compile your programs from the MS DOS command
     line.

     ASIC supports a large subset of BASICA and GWBASIC.  It supports over 90
     BASIC statements, decimal, integer and string variables and arrays.  It
     will compile your programs at high speed, and the code it generates is fast
     and compact.  The syntax of each ASIC statement is generally a valid subset
     of the syntax used by BASICA and GWBASIC (exceptions are noted in Chapter
     8.)

     Additionally, ASIC includes a conversion utility (BAS2ASI) to help you
     convert your GWBASIC programs to ASIC.  BAS2ASI is described in chapter 11.

          All you need to get started is:

               1)  ASIC
               2)  IBM PC or 100% Compatible
               3)  425k Available Memory
               4)  Two floppy disk drives
                        <or>
                   One hard disk drive and one floppy disk drive

          Optional:

               1) Microsoft Compatible Mouse

     The first step is to install ASIC as described below.  Then, proceed to
     Chapter 2 for a brief ASIC tutorial.  Following that you can read the
     remainder of the documentation straight through, or refer to it as you need
     it.  Have Fun!










                                      Page - 6


                                    INSTALLATION

     To conserve disk space, ASIC files are shipped in compressed format.  So,
     before you can run ASIC, you must first install it using the ASIC
     INSTALL.EXE program.  To do so, follow the instructions below.  Commands
     you type are listed in ALL CAPS .  Where you see <ENTER>, you should press
     the <ENTER> key on your keyboard.

     If you are installing to a 3 1/2" diskette or a 1.2 megabyte 5 1/4"
     diskette, you will need 1 blank formatted diskette.  If you are installing
     to a 360k diskette, you will need 2 formatted diskettes for a full install
     (or 1 formatted diskette if you opt to not install the documentation).  If
     you are installing to a hard disk, about 600k bytes are required for a full
     install (about 200k is required for a minimal install).  To install:

     1)   Insert your ASIC diskette into your floppy drive.

     2)   If the ASIC diskette is in drive A, type:    A:  <ENTER>
          If the ASIC diskette is in drive B, type:    B:  <ENTER>

     3)   Change the default directory by typing:      CD \  <ENTER>

     4)   Run the ASIC INSTALL.EXE program by typing:  INSTALL <ENTER>

     The ASIC install program will prompt you for the information it needs.  You
     will be asked for the following information:

     1)  The drive and directory containing the ASIC installation files.
     2)  The drive and directory you want ASIC installed to.

     You will be offered the option of installing (or not installing) the ASIC
     documentation files and sample programs.  It is recommended that you
     install all options.  Note:  If you do not install the documentation files,
     the online help function will not be available.  If you are installing to a
     360k 5-1/4" floppy diskette, the online help function will not be available
     inside the integrated editor.

     You may rerun the INSTALL program later to install options that you skipped
     the first time.















                                      Page - 7


                                       A S I C

                                      Chapter 2

                                      Tutorial

     ASIC programs look very much like regular "BASIC" programs which you are
     probably already familiar with.  The one very noticeable difference is that
     ASIC programs have no line numbers.  Let's take a look at a very simple
     program written both in GWBASIC/BASICA and in ASIC:

          GWBASIC/BASICA                          ASIC
          -------------------------+----------------------------------
                                   |
          10  I=I+1                |  ADDONE:  I=I+1
          20  PRINT I              |         PRINT I
          30  IF I<100 THEN 10     |         IF I<100 THEN ADDONE:
          -------------------------+----------------------------------

     Both of these programs do the same thing.  They display the numbers from 1
     to 100.  However, notice that ASIC allows you to use descriptive labels
     (ADDONE) instead of a line number (10).  These labels can be up to 80
     characters long!  Also note that the ASIC  "PRINT" and "IF" statements were
     indented only for increased program readability.  The ASIC program could
     just as well have been written as:

                                        ASIC
                           ------------------------------
                               ADDONE:I=I+1
                               PRINT I
                               IF I<100 THEN ADDONE:
                           ------------------------------

     We could have made our variable names longer.  Instead of "I" we could have
     chosen "SECONDS" or "VELOCITY", or some other name up to 80 characters in
     total.  In ASIC, variable names, labels, and string constants can all be up
     to 80 characters in length.

     Well, now that we've seen a basic ASIC program, let's try to enter and run
     a slightly larger program.  The program we will be working with will print
     the message "HELLO yourname" in 256 color combinations.  If you have a
     monochrome display card, don't worry, the program will work, but instead of
     seeing different colors you'll see characters with different attributes,
     such as blinking, underlined, etc.

     Let's get started.  If you haven't done so already, install ASIC as
     described in Chapter 1.  Now then, writing an ASIC program involves these
     three steps.

          1.  Write your program.
          2.  Compile your program.
          3.  Run/Test your Program.


                                      Page - 8


     These three steps can all be performed from within the ASIC Integrated
     Environment.  Before we proceed with our "Hello yourname" Program, let's go
     over some conventions.

          In the following section:

          FLOPPY TYPE-->      Means that only 2-floppy disk system users
                              should type this line.

          HARD TYPE-->        Means that only hard disk system users
                              should type this line.

          TYPE-->             Means that both floppy and hard disk users
                              should type this line.

          X>                  This is a representation of the prompt from
                              PC-DOS or MS-DOS.  Floppy Disk Users will
                              actually see "A>" for a prompt.  Hard Disk
                              Users will see "C>" for a prompt.

          <enter>             Means that you should press the <enter>
                              or <enter> key on your keyboard.

          <?>                 Text enclosed between the "<" and the ">"
                              symbols indicate a key to type.  Don't type
                              the "<" or ">" symbols.  For example, if the
                              tutorial lists "<F1>", your should press the
                              "F1" key on your keyboard.

     NOTE:  Floppy Disk users need to insert their ASIC Compiler diskette in
     Drive A: at this point, and a blank diskette in Drive B:  (See the
     Installation section for more information)

     The tutorial uses the keyboard for all commands, but includes a few notes
     on mouse usage.  For more information on using the mouse with ASIC see the
     "MOUSE USAGE" section in Chapter 3.

     Let's begin:

          FLOPPY TYPE-->      A: <enter>
          HARD TYPE-->        CD C:\ASIC <enter>

     The computer should respond:

                              X>

     Now enter the command to invoke ASIC:

          TYPE-->             ASIC <enter>

     You are now in ASIC.  The top line is the Menu Bar.  The bottom line is the
     Status Line.  Chapter 3 describes this in more detail.  For now, we'll just
     describe a couple of features on these lines.

                                      Page - 9



     The status line indicates that the current mode is "INSERT".  This means
     that any characters you type on a line will be inserted between the
     existing characters.  If you press the <INS> key on the keypad, ASIC will
     toggle to its other mode, OVERSTRIKE.  In this mode, when you type a
     character, it overlays the character that was there before.  Each time you
     press the <INS> key, ASIC will toggle between the INSERT and OVERSTRIKE
     modes.

     You can open the menus listed on the "Menu Bar" by holding down the ALT key
     while typing the Red Capitalized letter of the menu you wish to open.  For
     example, to open the File menu, press <ALT><F>.  Try it now:

          TYPE-->    <Alt><F>

     The "File" menu will pop open.  You can select a menu option from that menu
     by typing the capitalized letter of the option, or by using the arrow keys
     on your keypad to highlight the option you want and then pressing <enter>.

               MOUSE USERS:  If you have a mouse, you can open a menu
               by clicking the left mouse button on the menu name.
               For example, to open the "File" menu, position the
               mouse pointer anywhere on the word "File", and click
               the left button.

     If you are not sure what the menu option will do, you can press <F1> and
     ASIC will display some help information for the highlighted menu option.
     When you opened the File menu, the first option on that menu, "Open" was
     highlighted.  Let's get some help on "Open":

          TYPE-->    <F1>

     ASIC will display some help information on "Open".  Let's close the help
     window now:

          TYPE-->    <ESC>

     The help window will close.  The <ESC> key will always let you escape from
     any menu or help screen in ASIC, without taking any action.

               MOUSE USERS:  To close a menu you can click the right
               mouse button.  In fact, you can always use the right
               mouse button to cancel an option, instead of pressing
               the <ESC> key, if you prefer.

      Let's also close the file menu for now:

          TYPE-->    <ESC>

     The "File" menu should have closed.  By the way, in addition to the menu
     help, ASIC provides additional online help.  If you need general ASIC help,
     press the <F1> key for a quick summary of some of ASIC's features:


                                      Page - 10


          TYPE-->    <F1>

     ASIC will display some general help.  From this screen, we can also
     retrieve additional information about BASIC statements such as PRINT or
     GOSUB.  Let's bring up an index of these statements.

          TYPE-->    <F1>

     ASIC has opened a help index screen.  From this screen we can use the arrow
     keys to highlight any ASIC keyword and obtain more information for that
     keyword by then pressing enter.  We won't do that now, but don't forget
     that this screen is available. Chapter 3 of the ASIC Reference Manual
     describes all of the online "HELP" features available in ASIC and provides
     a full description of the ASIC Editor Commands which are available.  Exit
     the help menu:

          TYPE-->    <ESC>

     Entering a program in ASIC is simplicity itself.  We'll simply type in each
     line, pressing <enter> at the end of each line.  If you make a typing
     mistake, just use the arrow keys to move to the error, and type in the
     correction.  Use the <DEL> or <Backspace> keys to delete any unwanted
     characters from the screen.

     Make sure the status line says "Mode: Insert".  This is the default mode in
     ASIC.  If it doesn't, press the <INS> key until it does.  Now let's enter
     our program (the program below intentionally contains an invalid ASIC
     statement.  We'll correct the line later in the tutorial, for now, type in
     the program exactly as it's listed below):

          TYPE-->        CLS  <enter>
          TYPE-->        PRINT "Please enter your name"; <enter>
          TYPE-->        INPUT YOURNAME$  <enter>
          TYPE-->        FOR I=1 TO 16  <enter>
          TYPE-->            FOR J=1 TO 16  <enter>
          TYPE-->                COLOR I,J <enter>
          TYPE-->                PRINT "HELLO "; <enter>
          TYPE-->                PRINT YOURNAME$; <enter>
          TYPE-->            NEXT J <enter>
          TYPE-->        NEXT I <enter>
          TYPE-->        CLS <enter>
          TYPE-->        THE END <enter>

     There, that was easy.  Now, let's compile our program.  To do it, we'll
     open the "Compile" menu, and select the "Compile program" option:

          TYPE-->       <ALT><C>

     The "Compile" menu will pop open.  The first option, "Compile program" can
     be selected by typing the option letter which is capitalized "C", or by
     moving the highlight bar to this option and pressing the <enter> key.
     Since the highlight bar is already on this option, let's just press
     <enter>:

                                      Page - 11



               MOUSE USERS: To select an option with the mouse,
               position the mouse pointer on the option name and click
               the left mouse button.

          TYPE-->       <enter>

     Since we didn't specify a file name when we invoked ASIC, ASIC will now ask
     for a file name (so it can save your program before calling the compiler):

          FLOPPY TYPE-->      B:TUTOR.ASI  <enter>
          HARD TYPE-->        TUTOR.ASI <enter>

     Note that ASIC requires that your programs be stored in files ending with
     the extension ".ASI".  Had we entered "TUTOR" for our program name, ASIC
     would have appended the letters ".ASI" for us.  If we tried to provide a
     different extension, such as "TUTOR.SRC", ASIC would display an error
     message.

     Once you select the "Compile program" option, you'll see the ASIC compiler
     screen appear.  It will display a count of the lines compiled, and when it
     is done, it will return to the ASIC editor.

     If ASIC detected any errors, it will display the first error message at the
     bottom of the editor screen.  It will also highlight the line in your
     program which is in error.  In this case the line "THE END" was flagged
     with the error message "Syntax Error".  Of course, that line should have
     been entered simply as "END".

     That should be easy enough to fix.  Let's exit the error menu by pressing
     the <ESC> key:

          TYPE-->      <ESC>

     The error menu has disappeared, and our cursor is now on the erroneous
     line.  To fix the line:

          TYPE-->      <DEL><DEL><DEL><DEL>

     That should do it.  The last line of our program should now read "END".
     Before we continue, let's assume we knew the name of the END command, but
     could not remember the proper syntax for it.  ASIC provides an online
     lookup for each ASIC statement.  With the cursor positioned somewhere on
     the word "END":

          TYPE-->      <Ctl><F1>

     ASIC should have opened a help window describing the "END" statement.  To
     return to your program press the <ESC> key.

          TYPE-->      <ESC>



                                      Page - 12


     The help window should have disappeared and you should see your program
     displayed again.  Let's recompile the program:

          TYPE-->      <ALT><C>
          TYPE-->      <enter>

     This time you should see the message "No Compiler Errors". If you didn't,
     check your spelling and recompile the program until you receive this
     message.  Press <ESC> to remove the "No Compiler Errors" Window.

     Now let's run the program.  To do so, we'll open the "Run" menu, and select
     the "Run your program" option.

          TYPE-->      <ALT><R>
          TYPE-->      <r>

     This time, we just entered the capitalized letter from the menu option "Run
     your program".  Your computer screen should now prompt you to "Please enter
     your name?".  Go ahead and enter your name now:

          TYPE-->      yourname  <enter>

     You should see "HELLO yourname" printed in various color combinations, and
     then the ASIC editor screen will reappear.  Well, that's all there is to
     writing, compiling, and running an ASIC program.  Now, to exit ASIC, open
     the "File" menu and select the "eXit" option.

          TYPE-->      <ALT><F>
          TYPE-->      <X>

     You should see your MS DOS prompt once again.  By the way, now that you've
     successfully compiled the program, you can execute it directly from MS DOS.
     Let's try it:

          HARD TYPE-->     TUTOR <enter>
          FLOPPY TYPE-->   B:TUTOR <enter>

     Well, that's a brief introduction to ASIC!  Next, you might want to read
     Chapter 3, "Integrated Editor/Compiler Environment" to learn about the many
     other features available in the ASIC editor.  Following this you should
     read Chapter 4 which explains how to use the ASIC Debugger.  Chapter 4
     includes another short tutorial in which you debug a program.  Chapter 11
     provides information on converting your existing GWBASIC programs to ASIC
     format.

     The remaining chapters provide reference material which you can either
     read, or just refer to as needed.  Chapter 5 explains how to compile
     programs directly from the command line of DOS.  Chapters 6-8 describe the
     BASIC statements which are supported by ASIC.  Chapter 9 provides some
     technical information about ASIC.  Chapter 10 explains how to call ASIC or
     assembly language object modules from an ASIC program.  Chapter 12 provides
     more descriptive information for ASIC error messages.


                                      Page - 13


     Hope you enjoy programming in ASIC!





















































                                      Page - 14


                                       A S I C

                                      Chapter 3

                             Integrated Editor/Compiler
                                     Environment


                                    INTRODUCTION

     The ASIC integrated environment lets you edit, save, compile, and debug
     your ASIC programs without ever leaving ASIC!  This chapter will explain
     the usage of the integrated environment.

                                ASIC SCREEN CONTENTS

     ASIC divides the screen into three parts.  The top line is called the "Menu
     Bar".  All of the menus available to you are listed on this line.  The
     bottom line is called the "Status Line".  It continuously displays some
     important program information.  The middle 23 lines are the "Edit Window".
     This is the section of the screen where you can make changes or additions
     to your program.

                                 MENU BAR PROCESSING

     Currently, there are five menus available.  The "File" menu allows you to
     load/save your existing program files to/from disk.  It is also used to
     exit ASIC.  The "Edit" menu contains various editing commands which are
     available.  The "Compile" menu is used to compile your program, set
     compiler options, and to view compiler errors.  The "Run" menu allows you
     to run your programs, and test them using the ASIC debugger.  The "Help"
     menu provides help in using ASIC.

     To open a menu, hold down the <ALT> key and type the first letter of the
     menu.  The menu will pop down and display the options available on that
     menu.  If you want to close the menu without taking any action, press the
     <ESC> key.  If you wish to open a different menu without first closing the
     current menu, press the left or right arrow keys.

     Otherwise, to select an option, type the capitalized letter of the menu
     option.  For example, on the "File" menu, to select the "eXit" option, type
     an "X" or an "x".  Another way to select an option is to move the
     "Highlighted Bar" down to the option you wish to select, and press the
     <enter> key.

     Some functions may be accessed outside of the menus with short cut keys.
     For example, the "eXit    <ALT-X>" function in the file menu can be
     selected by holding down the ALT key and tapping the "x" key.  The short
     cut keys are listed on the menus following the option name (they are
     enclosed in brackets as in <F2> or <ALT-X>).  Not all menu options have
     short cut keys.  Note that these short cut keys do not operate when a menu
     is open.  (A list of these short cut keys is presented later in this
     chapter in the Keyboard Usage Section).

                                      Page - 15



                                     MOUSE USAGE

     If you are familiar with other Mouse Programs, such as Microsoft Windows,
     you will find that you will use the mouse in much the same way in ASIC.

     Menus can be opened by moving the mouse pointer to a menu name on the menu
     bar, and clicking the left mouse button.  Once the menu is open you can
     select an option by positioning the mouse pointer on the desired option,
     and clicking the left mouse button.  To close a menu without selecting an
     option, click the right button.

     A new feature added to several screens, is the "scroll bar".  Scroll bars
     let you scroll through lists of items in screen window. A vertical scroll
     bar appears on the right side of the main editor window (and on the file
     open, save, and some help screens).  At the top of the scroll bar is a
     small arrow that points upwards.  At the bottom of the scroll bar is a
     small arrow that points downwards.  Between the two arrows is a small
     square, called a slider.

     At the bottom of the main edit window there is also a horizontal scroll
     bar, that lets you scroll the edit buffer left and right.

     To use the scroll bar, click the left mouse button on one of the arrows to
     scroll the contents of a window by one line.   Click on the shaded area
     between the arrows to scroll a page at a time.  You can also "drag" the
     slider to any position on the scroll bar to scroll the window to the same
     relative position.  To drag the slider, position the mouse pointer on the
     slider, hold down the left mouse button, and move the mouse pointer to the
     desired position on the scroll bar.  Once at the desired position, release
     the mouse button.

     To select a block of text in the editor, position the mouse pointer on the
     first line in the block you wish to select.  Press and HOLD the left mouse
     button until the first line is highlighted.  Continue holding the left
     mouse button down, and drag the mouse pointer to the ending line of the
     block.  When you reach the last line you want to include in the block,
     release the left mouse button.

     When responding to dialog box messages, the left mouse button is the same
     as pressing  <ENTER>, and the right mouse button is the same as press the
     <ESC> key.

     To get context sensitive help for menu options or ASIC keywords, press and
     briefly HOLD the right mouse button.

     To position the keyboard cursor, move the mouse pointer to the desired
     location in the edit window, and click the left mouse button.  The cursor
     will move to the mouse pointer location.





                                      Page - 16


                             EDITOR COMMAND LINE OPTIONS

     When you start ASIC, you may optionally specify a number of command line
     arguments.  The command line syntax for ASIC is:

                    ASIC [filename] [/MONO] [/NOMOUSE]

     Options shown in brackets "[]" are optional.  Don't type the brackets.

     filename  The filename parameter is used to specify a program that ASIC
               should load into the edit buffer when starting up.

     /MONO          This option instructs ASIC to run in Black and White, even
                    if a color graphics card is detected.  This option is useful
                    for laptops with B/W screens.

     /NOMOUSE  This option instructs ASIC to ignore the Mouse.  ASIC will not
               attempt to detect or use your Mouse.

     Examples of ASIC command lines:

                    ASIC LIFE.ASI
                    ASIC LIFE.ASI /MONO
                    ASIC LIFE /NOMOUSE
                    ASIC LIFE /MONO /NOMOUSE


                                    GETTING HELP

     ASIC provides "online" help within the integrated environment to assist you
     with keyboard usage, menu options, and ASIC keywords.  This section tells
     you how to access this online help.

     General Help

     Keyboard, keyword syntax, and ASCII character codes help is available from
     the Help Menu.  Open the Help menu by holding down the <alt> key and
     pressing the "h" key.  You can also directly display keyboard help by
     pressing <F1>.

               MOUSE USERS:  You can select help by positioning the
               mouse pointer on  the "Help" Menu on the menu bar, and
               clicking the left mouse button.

     Menu Help

     If you open a menu, but you are not sure what a certain menu option does,
     you may display a description of the highlighted menu option by pressing
     the <F1> key.  Doing so will open a help window which describes the menu
     option.  Press <ESC> to exit the help screen and return to the menu.




                                      Page - 17


               MOUSE USERS:  You can get help for a menu option with the mouse
               as follows.  Position the mouse pointer on the menu option, and
               press and briefly HOLD the right mouse button.

     Keyword Help

     Can't remember the syntax for a particular ASIC keyword?  Well, help is
     just a keystroke away.  Position the cursor on the keyword in the edit
     buffer.  Then, hold down the <Ctl> key and press the <F1> key.  ASIC will
     display a description of the keyword, and describe proper syntax for that
     keyword.  For example, if you tried to compile a program, but received a
     syntax error on the keyword "PRINT" in your program, you could obtain help
     on the "PRINT" statement by using the arrow keys to position the cursor
     anywhere on the word "PRINT" and then pressing <Ctl-F1>.  If ASIC cannot
     find the keyword (e.g., say the cursor was positioned on a variable called
     "APPLES", which is not an ASIC keyword), then ASIC will display a list of
     valid keywords.  Use the cursor keys to highlight one of these keywords and
     press <enter> to retrieve help for the highlighted keyword.  You may also
     access this keyword help list by pressing the <F1> key twice from within
     the editor, or by selecting the "Keyword Index" option from the Help Menu.

               MOUSE USERS:  You can also get keyword help using the mouse.
               Position the mouse pointer on the keyword, and press and briefly
               HOLD the right mouse button.


                                      FILE MENU


     "New"     Option

     This option allows you to clear the edit buffer and create a new program.


     "Open...   <F3>" Option

     This option allows you to open an existing ASIC file and load it into the
     ASIC edit buffer where you can modify it.  If you select this option
     another window will open to ask you the file name.  If you don't wish to
     open a file, you can press <ESC> to close the menu without taking any
     action.  Otherwise, enter an ASIC file name, and press the <enter> key.  If
     the file already exists, you can also select the file name from the list
     displayed, by using the arrow keys or mouse to scroll through the list of
     file names.  To select a file from the list, press <ENTER>, or position the
     mouse pointer on the file name, and click the left mouse button.  This
     option may also be selected outside of the menu by pressing the <F3> key.








                                      Page - 18


     "Convert..." Option

     This option will allow you to convert a GWBASIC program to ASIC format.
     When you select this option, a file dialog box will be displayed showing
     all files with ".BAS" extensions in the ASIC directory.  Enter filename of
     the file to be converted, and press <enter>.  You can also select the file
     name from the list displayed, by using the arrow keys or mouse to scroll
     through the list of file names.  To select a file from the list, press
     <ENTER>, or position the mouse pointer on the file name, and click the left
     mouse button.  The file will be converted to a file with the same name, but
     with a ".ASI" extension.  Note:  The file must have been saved by GWBASIC
     in ASCII format (i.e., SAVE "filename.BAS",A).


     "coMments include" Option

     When converting a GWBASIC program to ASIC format, if this option is set,
     ASIC will include the original program source lines in the converted file
     as comments.  When this option is set, a small checkmark will appear at the
     left of the option name.


     "Warnings include" Option

     Set this option if you want ASIC to generate helpful warnings when
     converting GWBASIC programs to ASIC format.  When this option is set, a
     small checkmark will appear at the left of the option name.


     "Errors include" Option

     Set this option if you want ASIC to generate error messages for unconverted
     statements, when converting GWBASIC programs to ASIC format.  When this
     option is set, a small checkmark will appear at the left of the option
     name.


     "Dos shell" Option

     This option allows you to temporarily exit to MS DOS to execute one or more
     DOS commands or other programs.  When you are ready to return to ASIC, type
     EXIT <enter>.


     "Save   <F2>" Option

     This option allows you to write the changes you've made to your program
     back to the file.  Changes you enter in the ASIC editor are made to memory
     only.  You must select this option before your changes will become
     permanent.  Note:  Your file is saved to disk automatically whenever you
     compile it or run it, if the file has been modified.  This option may also
     be selected outside the menu by pressing the <F2> key.


                                      Page - 19


     "save As..." Option

     This option will allow you to write the changes you've made to the program
     in the edit buffer to a new file.  You will be prompted to provide ASIC
     with a new file name.  If  you want to overlay an existing file, you can
     select the file name from the list displayed by using the arrow keys or
     mouse to scroll through the list of file names.  To select a file from the
     list, press <ENTER>, or position the mouse pointer on the file name, and
     click the left mouse button.  BE CAREFUL--WHEN YOU SELECT A FILE FROM THE
     LIST, YOU ARE TELLING ASIC TO OVERLAY AN EXISTING FILE.


     "auto Indent" Option

     When this option is selected, ASIC will automatically position the cursor
     on inserted lines in the same column as the first non-blank character in
     the preceding row.  When this option is set, a small checkmark will appear
     at the left of the option name.  When this option is not selected, ASIC
     will position the cursor on inserted lines in column 1.


     "eXit   <Alt-X>" Option

     This option will allow you to exit from ASIC back to MS DOS.  ASIC will ask
     you if you wish to save your file before you exit.  This option may be
     selected outside this menu by pressing <ALT-X>.


                                      EDIT MENU


     "Begin block" Option

     This option will allow you to mark the beginning of a block of text for use
     with the block delete, copy, and move commands.  To mark a block of text,
     move the cursor to the first line of the block, and then select this
     option.  The beginning line of the block will be highlighted on the screen.
     Next, move the cursor to the ending line of the block, and select the "End
     block" option from this menu.  All of the lines in the block will be
     highlighted.  This block of lines can now be "moved", "copied", or
     "deleted" using the block commands.  If you have a mouse, you can select
     text without using the "Begin Block" and "End Block" options.  To select a
     block of text with the mouse, position the mouse pointer on the first line
     in the block, press and HOLD the left mouse button until the line is
     highlighted, and (while continuing to hold down the left mouse button) drag
     the mouse pointer to the ending line of the block.  Once you reach the
     ending line of the block, you may release the left mouse button.  The block
     should be highlighted on the screen.






                                      Page - 20


     "End block" Option

     This option will allow you to mark the end of a block of text.  Refer to
     the "Begin block" Option for more information.


     "Search..." Option

     This option allows you to locate a string of characters in the edit buffer.
     When you select this option, ASIC will ask you for a search string which
     can be up to 30 characters in length.  ASIC will then search forward from
     the current line until it finds the string or reaches the end of the edit
     buffer.  If it finds the string, the cursor will be placed on the line
     containing the string.


     "Replace..." Option

     This option will allow you to replace one or more occurrences of a string
     of characters with another set of characters.  When you select this option,
     ASIC will ask you for a search string which can be up to 30 characters in
     length.  ASIC will then ask you for the string of characters which is to
     replace the search string.  Finally, ASIC will ask you to specify how many
     occurrences of this search string are to be replaced (from 1-9999).  ASIC
     will search forward from the current line, and briefly display each line as
     it modifies it.  If it reaches the end of the edit buffer before it has
     replaced the number of occurrences you've specified, ASIC will display an
     "End of Buffer" message, and stop.


     "Delete block" Option

     This option will delete a block of lines.  Refer to the "Begin block"
     option for information on marking a block of lines.  If you haven't marked
     a block of lines, selecting this option will have no effect.


     "Move block" Option

     This option will move a block of lines to a new location in the edit
     buffer.  Refer to the "Begin block" option for information on marking a
     block of lines.  If you don't mark a block of lines, selecting this option
     will have no effect.  Once you have marked a block of lines, move the
     cursor to the location in the edit buffer where you want the lines moved.
     Selecting the "Move block" option will result in the block of lines being
     deleted from their current location, and moved to the buffer at the line
     following the cursor.  ASIC will not overlay lines, it will insert enough
     blank space to hold the relocated text.






                                      Page - 21


     "Copy block" Option

     This option is the same as the "Move block" option, with one exception.
     After moving the block, ASIC does NOT delete the original block of lines.
     Use this option to clone a block of text.  Refer to the "Begin block"
     option for information on marking a block of text.


     "search Again <CTL-L>" Option

     This option will allow you to search for the next occurrence of the last
     string you searched for with the "Search" Option, without retyping the
     previous search string.  This option may also be selected outside of the
     Edit Menu by pressing <CTL-L>.


                                    COMPILE MENU


     "Compile program <F10>" Option

     Use this option to have ASIC compile the program which is currently loaded
     in the edit buffer.  If the compile is successful, ASIC will display the
     message "No Compiler Errors".  Otherwise, it will display the first error
     message (see "View compile errors" option).  ASIC will automatically save
     your program before calling the compiler.  This option may also be selected
     outside of the menu by pressing function key <F10>.


     "Advanced options" Option

     Select this option to bring up a menu of compiler options for the advanced
     ASIC user.


     "Full program listing" Option

     This menu option, and the next six options are used to toggle various
     compiler options on or off.  When the option is on, you will see a "check
     mark" symbol next to the option.  This compiler option will cause ASIC to
     display each source line as it compiles it.  This option will slow down the
     compile, but since ASIC also writes these lines to a listing file, this
     option can be used to create a compile listing.  The compile listing will
     be contained in a file called "progname.LST", where "progname" is the name
     of your program.


     "Printer output" Option

     This menu option will toggle the "Printer output" compiler option on or
     off.  When the option is on, you will see a "check mark" symbol next to the
     option name.  This compiler option will cause compiler messages to be
     printed on your printer.

                                      Page - 22


     "Symbol table" Option

     This menu option will toggle the "Symbol table" compiler option on or off.
     When the option is on, you will see a "check mark" symbol next to the
     option name.  This compiler option will cause ASIC to create a symbol table
     file called "progname.SYM", where "progname" is the name of your program.
     The symbol table is a list of all variables, labels, and internally created
     compiler addresses.


     "Extended math" Option

     By default, ASIC will permit regular integer variables. These variables are
     very efficient and only require two bytes (or characters) of memory
     storage.  However, these integers can only hold numbers in the range of -
     32767 to +32767.  For many programs this is sufficient.  However, there may
     be cases when you want to represent larger integer values.  Because of
     this, ASIC provides a "long" integer data type.  The long integer requires
     four bytes of memory storage.  However, it can hold a much larger range of
     numbers.  A long integer can store numbers in the range of -2,147,483,647
     to +2,147,483,647.  When you need to use long integers in your program, you
     need to turn on this option, so that ASIC can generate the proper code.
     When the option is on, you will see a "check mark" symbol next to the
     option name.  If this option is not turned on and your program contains
     long integers, ASIC will generate a compiler error.  If this happens, just
     turn this option on, and re-compile your program.  To "create" a long
     integer variable or constant, simply append the "&" character to the
     variable name or constant value(e.g., SAMPLEVAR& or 123456&).  For further
     information on using long integers, refer to Chapter 6, "Language
     Elements", of the ASIC Manual.


     "decimal Math" Option

     Select this option if your program needs to perform decimal math.  When the
     option is on, you will see a "check mark" symbol next to the option name.
     When you select this option, ASIC generates supporting code for your
     program which supports the "Decimal" variable type.  Decimal variables may
     be identified by adding a "@" symbol following the variable name. (e.g.,
     BALANCE@).  "Decimal" type variables can contain numbers in the range of
     +999,999,999,999.99999 to -999,999,999,999.99999.  Unlike floating point
     numbers in GWBASIC or BASICA, ASIC "Decimal" variables do not exhibit
     rounding errors.  Full precision is maintained through all 5 decimal places
     (digits following the fifth decimal place are truncated).  For further
     information on using decimal variables, refer to Chapter 6, "Language
     Elements", of the ASIC Manual.  If this option is not turned on and your
     program contains decimal variables or constants, ASIC will generate a
     compiler error.  If this happens, just turn this option on, and re-compile
     your program.





                                      Page - 23


     "Debugging code" Option

     This menu option will toggle the "Debugging code" compiler option on or
     off.  When the option is on, you will see a "check mark" symbol next to the
     option name.  This compiler option will cause ASIC to generate code
     required by the ASIC debugger to allow you to set breakpoints, single step
     through your program, and view/modify program variables.  This option is
     "on" by default in the integrated environment.  You should leave this
     option on while you are debugging your program.  When you have everything
     working properly, you should turn it "off" and recompile your program.
     This will reduce the size of your program slightly, and will make it run
     faster (of course, you can't use the debugger with it, since there is no
     debugging information available to ASIC any more.  If you need to debug
     your program again, just recompile with the this option turned "on" again).


     "View compile errors" Option

     When you wish to examine the errors from a previous compile of your
     program, select this option.  If no errors exist, ASIC will so inform you.
     Otherwise, ASIC will display the first error message at the bottom of the
     screen, and it will highlight the line of your program which corresponds to
     that error.  If you wish to correct the program line, press the <ESC> key.
     The cursor will be positioned at the beginning of that program line.  You
     may also view subsequent compiler errors by pressing the <ENTER> key
     instead of the <ESC> key.


     "Write options to disk" Option

     Writes current compiler options to a file called ASIC.CFG.  When you enter
     ASIC, ASIC always reads options from this file.  Note that when you open a
     program, ASIC first checks for a "progname.PRJ" file.  The ".PRJ" file ,if
     found, will override ASIC.CFG.  Since ASIC automatically creates/updates
     the ".PRJ" file whenever you save a program, normally the only time that
     the ASIC.CFG options will be used is when you enter the editor with a new
     file.  Once you save a program the first time, ASIC creates the custom
     ".PRJ" file for the program.  Think of the ASIC.CFG file, then, as the
     default options for new programs.


                                  ADVANCED OPTIONS
                             (SUBMENU OF "COMPILE" MENU)

     When you select the "Advanced options" option from the "Compile" menu, this
     sub-menu will be displayed.  These give the advanced programmer the ability
     to tell ASIC how to produce the compiler output files.







                                      Page - 24


     "Com output file" Option

     This option, the "Exe output file", and the "Obj output file" options allow
     you to tell ASIC what type of output file to produce when compiling.  Only
     one of these three options may be selected at the same time.  The option
     that is currently selected will be preceded with a small dot.  This option
     is the default option.  When you select this option, ASIC will produce a
     ".COM" output file.  This file can contain a maximum of 64k bytes of
     program code and data.


     "Exe output file" Option

     This option, the "Com output file", and the "Obj output file" options allow
     you to tell ASIC what type of output file to produce when compiling.  Only
     one of these three options may be selected at the same time.  The option
     that is currently selected will be preceded with a small dot.  When you
     select this option, ASIC will produce a ".EXE" output file.  This output
     file can contain up to 64k program code, 64k program data, and 64k stack.
     ASIC does not produce an intermediate OBJ file, and ASIC uses its internal
     linker.  Unlike the "Obj output file" option, ASIC does not use the DOS
     LINK command to produce the EXE file, and no OBJ file is created when using
     this option.  Turn this option on when:  1) you want to compile large
     programs, 2) you want to minimize the amount of memory required when your
     program runs, or 3) you want  to adjust the program stack size.  The only
     drawback to this option, is that the EXE file is slightly larger on disk
     than the COM file, and that ASIC only asks DOS for the amount of memory
     your program needs.  With COM files, DOS gives your program all available
     memory.  Note:  If you compile a program with this option turned off, and
     then turn this option on, be sure to recompile your program.
























                                      Page - 25


     "Obj output file" Option

     This option, the "Exe output file" option, and the "Com output file" option
     allow you to tell ASIC what type of output file to produce when compiling.
     Only one of these three options may be selected at the same time.  The
     option that is currently selected will be preceded with a small dot.  When
     you select this option, ASIC will produce a ".OBJ" output file that is in
     the standard MS DOS LINK format.  This file is not directly executable.
     First, it must be "LINK"ed into a ".EXE" file.  ASIC will attempt to call
     the MS DOS LINK program for you. To do so, it must be able to locate the
     "LINK.EXE" program (provided with MS DOS).  It will search for this file in
     the current directory, and the "C:\DOS" subdirectory.  If it can't find the
     file there, it will not be able to link your program.  ASIC does provide a
     new option, to let you specify the location of the LINK.EXE program (see
     "Link.EXE path" option).  You may be wondering why you'd want to go through
     all of the bother of using this option, when you could create an EXE file
     directly using the "EXE output file" option.  Well, normally you will want
     to use the "EXE output file" option.  But, the "OBJ output file option
     provides one important advantage.  Using this option, you can use the CALL
     SUB statement in your programs, and you can tell ASIC to link in other OBJ
     files (created with ASIC or an assembler) with your ASIC program.  See
     chapter 10 of the ASIC manual for more information.  Also, refer to the
     "obJect names..." option, the "liBrary name..." option, and the "Link.exe
     path..." option on this same menu.


     "Stack size..." Option

     This option will allow you to adjust the size of the stack that ASIC
     generates for your program.  When you select this option, you will be
     prompted for the number of bytes to allocate to the stack in your program.
     If you select a number that is too small for your program's needs, the
     results when you attempt to run your program will be unpredictable.  The
     ASIC defaults are 2000 bytes (4000 bytes in debugging mode).  Note that if
     you compile with debugging mode on and specify a stack size of less than
     4000 bytes, ASIC will ignore your stack size and continue to use 4000
     bytes.  This option has no effect when you are using the "Com output file"
     option.
















                                      Page - 26


     "obJect names..." Option

     This option allows you to identify other object file names that ASIC should
     pass to the DOS LINK.EXE program.  This option is ignored by the compiler
     unless you are compiling with the "Obj output file" Option.  When you
     select this option, ASIC will prompt you for a list of object names.  Each
     object file name should be separated from each other by a "+" sign.  For
     example, to identify OBJECT1.OBJ and OBJECT2.OBJ you would enter:
     OBJECT1.OBJ+OBJECT2.OBJ for the object names.  Since the LINKer expects the
     file extensions to be ".OBJ", you can omit the extension as long as it is
     ".OBJ".  For example, we could have entered:  OBJECT1+OBJECT2.  By default,
     the linker will assume that the object files will be in the current
     directory, so if they're somewhere else, be sure to include the full path,
     as in:   C:\OBJECT\OBJECT1+C:\OBJECT\OBJECT2.  Refer to Chapter 10 of the
     ASIC Manual for more information.


     "liBrary names..." Option

     This option allows you to identify object program libraries (such as those
     built with the Microsoft LIB command) that ASIC should pass to the DOS
     LINK.EXE program.  This option is ignored by the compiler unless you are
     compiling with the "Obj output file" Option.  When you select this option,
     ASIC will prompt you for a list of library file names.  Each library file
     name should be separated from each other by a "+" sign.  For example, to
     identify LIB1.LIB and LIB2.LIB you would enter: LIB1.LIB+LIB2.LIB for the
     library names.  Since the LINKer expects the file extensions to be ".LIB",
     you can omit the extension as long as it is ".LIB".  For example, we could
     have entered:  LIB1+LIB2.  By default, the linker will assume that the
     library file will be in the current directory, so if the libraries are
     elsewhere, be sure to include the full path, as in:
     C:\LIB\LIB1+C:\LIB\LIB2 for example.  Refer to Chapter 10 of the ASIC
     Manual for more information.


     "Link.exe path..." Option

     This option is used to tell ASIC where to find the MS DOS LINK.EXE program.
     This option is ignored by the compiler, unless you are using the "Obj
     output file" Option.  When you use the "Obj output file" Option, ASIC
     utilizes the LINK.EXE program, which is provided with MS DOS, to link your
     ASIC program and additional object files into an MS DOS EXE file.  If you
     do not provide a path, ASIC will attempt to find LINK.EXE under the current
     directory, and under the "C:\DOS" directory (if applicable).  If it can't
     find the program in either place, the EXE file will not be built.  When you
     select this option, you will be prompted to enter the directory in which
     ASIC may find the LINK.EXE program.  For example, if you determined that
     the LINK.EXE program is stored under "C:\UTIL" on your hard disk, you would
     enter:  C:\UTIL for this option.  On future compiles, ASIC will look for
     the LINK.EXE file in the "C:\UTIL" directory.  Instead of using this
     option, you may also copy the LINK.EXE file to your ASIC directory.



                                      Page - 27


                                      RUN MENU

     The "Using the ASIC Debugger" Chapter has additional information on the
     debugger and it's options.  You may wish to refer to it, should you need
     more information than is provided below.


     "Run your program <F5>" Option

     After you have successfully compiled your program, you can select this
     option to cause ASIC to load and execute your program.  After your program
     ENDs, ASIC will return you to the editor.  ASIC will save the edit buffer
     before loading and executing your program.  If you are running a program
     containing debugging code, this option will cause ASIC to run your program
     up to the first breakpoint it encounters, or through the end of your
     program if you haven't set any breakpoints.  If you are already "paused" at
     a breakpoint, selecting this option will cause your program to resume
     execution at the statement following the breakpoint, and run up to the next
     breakpoint or to the end of your program, if no further breakpoints are
     encountered.  This option may also be selected outside of the "Run menu" by
     pressing function key <F5>.


     "Breakpoint toggle <F9>" Option

     If you have compiled your program with the "Debugging code" option turned
     on, you may use this option to set breakpoints.  You can have up to 20
     breakpoints active at a time.  When you run your program with breakpoints
     set, ASIC will pause your program when it tries to execute a line on which
     you have set a breakpoint.  At this time, you can view or modify variables,
     or view the screen output produced by your program.  You can then resume
     program execution by selecting the "Run your program" option from the run
     menu.  If you select this option and the current statement in the edit
     buffer already has a breakpoint set, then the breakpoint for that source
     statement will be removed (toggled off).  Lines at which you have set a
     breakpoint will be displayed in reverse video.  Also, when you run your
     program and ASIC stops at a breakpoint, ASIC will display the next line to
     execute in reverse video on the second line of the screen with a red
     background (underlined if you have a monochrome system).  This option may
     also be selected outside of the "Run" Menu by pressing function key <F9>.














                                      Page - 28


     "Trace <F8>" Option

     If you have compiled your program with the "Debugging code" option turned
     on, you may use this option to execute your program one statement at a
     time.  After you select this option, ASIC will execute the next program
     statement in your program, and pause, displaying the next line which will
     be executed in reverse video with a red background (underlined if you have
     a monochrome system).  At this time, you can view or modify variables, or
     view the screen output produced by your program.  You can then resume
     program execution by selecting the "Run your program" option from the run
     menu, or by selecting the "Trace" option again.  This option may also be
     selected outside of the "Run" Menu by pressing function key <F8>.


     "Modify variable..." Option

     If you have compiled your program with the "Debugging code" option turned
     on, you may use this option to modify the contents of variables in your
     program while your program is paused at a breakpoint or following a "Trace"
     command.  When you select this option, ASIC will ask you for the variable
     name.  After you enter the variable name, ASIC will ask you for the new
     value to be stored in the variable.  If the variable is an array, ASIC will
     ask you which element of the array to modify.


     "Watch variable... <F6>" Option

     If you have compiled your program with the "Debugging code" option turned
     on, you may use this option to view the contents of variables in your
     program, while your program is paused at a breakpoint or following a
     "Trace" command.  After you enter the variable name, ASIC will open a
     "Watch" window at the bottom of the screen showing you the variable name
     and the current value.  As you continue execution of your program and reach
     a new breakpoint, the values of variables will be updated to reflect their
     new values.  In this way you can watch the changing values of variables in
     your program without inserting "PRINT variablename" statements in your
     program.  Up to 10 variables may be watched at a time.  If you enter a
     variable name which is an array, ASIC will ask you which element of the
     array you wish to watch.  This option may also be selected outside of the
     "Run" Menu by pressing function key <F6>.














                                      Page - 29


     "Unwatch variable... <F7>" Option

     If you have compiled your program with the "Debugging code" option turned
     on, you may use this option to remove variables from the "Watch" window
     (see previous option).  When you select this option, you will be asked for
     a variable name to remove from the window.  If the variable is an array,
     you will also be asked which element of the array.  ASIC will then remove
     the variable from the watch window, and resize the window accordingly.
     Since only 10 variables may be watched concurrently, you may need to remove
     variables which are no longer needed from the "Watch" Window using this
     command.  This option may also be selected outside of the "Run" Menu by
     pressing function key <F7>.


     "Abort execution" Option

     If you are running your program, and it is paused at a breakpoint, you may
     select this option to abort the execution of your program.  Your program
     will be terminated immediately.


     "Clear all break/watch" Option

     If you have set breakpoints or watch variable options, you may use this
     option to remove all of them at once, instead of removing them one at a
     time using the "Toggle breakpoint" or "Unwatch variable" options.


     "Program arguments..." Option

     This option allows you to pass command line arguments to your programs,
     which may be retrieved by your program using the COMMAND$ statement.  If
     you are testing outside the integrated environment, you would normally
     specify the command line arguments by typing "progname arguments".
     However, in the integrated environment, since ASIC is executing your
     program for you, this option is a means to pass the "arguments" to your
     program as if they had been typed on the command line following your
     program name.


     "Swap to user screen <F4>" Option

     Whenever ASIC pauses your program at a breakpoint, it saves the screen
     created by your program in a memory buffer.  You may select this option to
     view your program screen output.  When you are done viewing your program's
     output, press a key to return to viewing the ASIC editor.  This function
     may also be selected outside the "Run" Menu by pressing the <F4> function
     key.






                                      Page - 30


                                      HELP MENU


     "General Help <F1> " Option

     This option will display general help about using the keyboard.  This
     option can also be accessed outside the Help Menu by pressing the <F1> key.


     "Keyword Index" Option

     Select this option to obtain help on the use of a specific ASIC keyword.


     "ASCII Chart" Option

     This option will display a list of ASCII characters and their corresponding
     ASCII codes.


     "aBout ASIC" Option

     This option will display a dialog box containing information about this
     version of ASIC.



                                     STATUS LINE

     The bottom line of the ASIC screen is called the "Status Line".  As it's
     name implies, it is used to display various types of status information.
     At the left of the status line "FILE: xxxxxxxx.xxx" will display the name
     of the file which is currently loaded in the edit buffer.  If you haven't
     opened a file yet, the file name will be blank.

     After the file name is the "File Modified Indicator".  If you have entered
     any changes in the edit buffer, and have not saved them to disk, an "*"
     will appear to indicate this.  If the edit buffer has not been modified
     since the last save to disk, no "*" will be present.

     The next piece of information is "Mode:".  Mode will always display one of
     two values:  "Insert" or "Ovrstr".  In "Insert" mode, any characters you
     type in the edit buffer will be inserted at the cursor position, and the
     characters to the right of the cursor will be shifted to the right by one.
     In "Ovrstr" mode, any characters you type in the edit buffer will overlay
     (and thus destroy) the character at the cursor position.  You can change
     back and forth between these two modes by pressing the <INS> key on your
     keypad.

     To the right of "Mode:" ASIC displays how many thousands of bytes are still
     available for use by ASIC.   You will see this number decrease as you add
     more lines to your programs.


                                      Page - 31


     The "Line: nnnn" status indicator, will identify which line of the file is
     being displayed.  For example, if the display reads "Line: 100", the line
     containing the cursor is the 100th line in the file. When ASIC is reading
     or writing your program to/from disk, it will display a running total of
     the number of records read/written in this field.

     The "Row:" and "Col:" numbers identify the relative position of the cursor
     within the "Edit Window".


                                     EDIT WINDOW

     The edit window is the area of the screen where your program is displayed.
     It displays up to 21 lines of your program at a time.  You can use the keys
     described below to manipulate the text in this window.


                                   KEYBOARD USAGE

     Most keys on the keyboard behave in ASIC just as you'd expect.  The key
     usages which might not be obvious are described here.

     <ESC>          Exit from any menu without taking any action.

     <TAB>          Move the cursor to the next "tab stop".  Tab stops in
                    ASIC are fixed at every fourth column (4,8,12,etc).

     <HOME>         Move the cursor to the beginning of the current line.

     <END>          Move the cursor to the first blank character following
                    the last non-blank character on the current line.

     <DEL>          Delete the character at the cursor position.

     <INS>          Toggle between Insert and Overstrike Modes.

     <PGUP>         Display the previous "page" of the edit buffer.

     <PGDN>         Display the next "page" of the edit buffer.

     <Ctl-PGUP>     Display the first "page" of the edit buffer.

     <Ctl-PGDN>     Display the last "page" in the edit buffer.

     <Backspace>    Delete the character to the left of the cursor
                    position, and move the cursor one column to the left.
                    If the cursor  is in column 1, the current line will be
                    "joined" with the previous line.

     <Up Arrow>     Moves cursor up one line.

     <Down Arrow>   Moves cursor down one line.


                                      Page - 32


     <Left Arrow>   Moves cursor left one column.

     <Right Arrow>  Moves cursor right one column.

     <Ctl-LfArrow>  Moves cursor left one word.

     <Ctl-RtArrow>  Moves cursor right one word.

     <Ctl-L>        Repeats the last "Search" command.  See Edit Menu
                    Section of this chapter for more information.

     <Alt-A>        Add a line following the line containing the cursor.

     <Alt-D>        Delete the line containing the cursor.

     <Alt-I>        Insert a line before the line containing the cursor.

     <Alt-X>        Exit ASIC.

     <F1>           Displays a help screen.

     <CTL-F1>       Displays help information for the keyword located at
                    the cursor position.

     <F2>           Saves the edit buffer to disk.

     <F3>           Load a new file into the edit buffer.

     <F4>           Swaps the display to the output from your program
                    temporarily.  See Run Menu Section of this chapter for
                    more information.

     <F5>           Runs your program.  See Run Menu Section of this
                    chapter for more information.

     <F6>           Add a variable to the "Watch" Window.  See Run Menu
                    Section of this chapter for more information.

     <F7>           Remove a variable from the "Watch" Window.  See Run
                    Menu Section of this chapter for more information.

     <F8>           Execute a single statement of your program.  See Run
                    Menu Section of this chapter for more information.

     <F9>           Toggle breakpoint on/off at the current edit buffer
                    line.  See Run Menu Section of this chapter for more
                    information.

     <F10>          Compile your program.  See Compile Menu Section of
                    this chapter for more information.




                                      Page - 33


     <enter>        In Insert mode, pressing <enter> is identical to
                    pressing <Alt-A>.  In OvrStr mode, pressing <enter>
                    is identical to pressing the <Down Arrow> key.



















































                                      Page - 34


                                       A S I C

                                      Chapter 4

                                 Using the Debugger

                                    INTRODUCTION

     The source level debugger in ASIC's integrated programming environment
     helps you debug your programs by allowing you to "peek" inside them as
     they're running.  You can single step through your programs, or select
     places in the program where you wish execution to pause by setting
     breakpoints.  Then, while the program is paused, you can view or modify any
     of your program's variables, and also examine the screen output created by
     your program.

     All of the debugger's commands can be selected from the run menu, and they
     are described in the "RUN MENU" Section of Chapter 3, "Integrated
     Editor/Compiler Environment".  Many of the debugger commands may be
     selected outside the "Run" menu, by pressing a function key (e.g.,
     <F5>,<F6>,etc.).  A complete list of the function keys available is
     contained in Chapter 3, in the "KEYBOARD USAGE" Section.

     This chapter explains how to use the debugger with a short tutorial which
     guides you through a sample debugging session.  The tutorial is followed by
     a reference section which you should read after completing the tutorial.


                                  DEBUGGER TUTORIAL

     The debugger tutorial follows the same format as the general tutorial in
     chapter 2.  You should complete (or at least review) the general tutorial
     before taking the debugger tutorial.

     This tutorial will use a program file provided with your ASIC compiler
     package called "DBGTUTOR.ASI".  If you are running from a hard disk, make
     sure it is in the ASIC directory.  If you are running from a two-floppy
     system, make sure it is on the diskette in drive b:, with the compiler in
     drive a:.

     NOTE:  Floppy disk users should verify that the ASIC compiler diskette is
     in drive A: and the "DBGTUTOR.ASI" disk is in drive b: before proceeding.

     Let's get started:

          FLOPPY TYPE-->      A: <enter>
                              ASIC B:DBGTUTOR <enter>

          HARD TYPE-->        C: <enter>
                              CD C:\ASIC <enter>
                              ASIC DBGTUTOR <enter>



                                      Page - 35


     You should be in ASIC now, and you should see a source program.  The first
     few lines should contain:

                         dim scores(10)
                         data 55,33,877,99,44,101,21,88,105,1
                         rem DBGTUTOR.ASI
                              .
                              . (etc.)
                              .

     This sample program will sort an array of 10 scores into ascending
     sequence.  It uses a simple "bubble" sort algorithm.  The "bubble" sort
     algorithm simply steps through each element of the array and compares it to
     its next higher neighbor.  If its neighbor's value is less than its own,
     the two values are swapped.  It is necessary to execute this process N-1
     times where N= number of items to sort.  Here's why.  Let's say the lowest
     value to be sorted was "1" and it is in array element "10" (assume 10
     numbers will be sorted).  The first swapping pass will result in the "1"
     being swapped from element 10 to element 9 of the array.  An additional 8
     passes through the array are necessary to move the "1" to array element
     number 1.  This algorithm gets its name, because the process of moving the
     elements has been compared to that of bubbles slowly rising to the surface.

     This program has a list of ten scores to be sorted.  Line 5 of the program
     will read the ten scores to an array called "Scores", and also print the
     original values (before the sort) to the screen.  Then two loops will
     execute at statements 8 and 9 in the program to perform the bubble sort as
     described above.  Finally, after the sort is complete, the sorted values
     will be displayed.

     First, let's compile the program.  When we plan to use the debugger, we
     must set the "Debugging code" option on.  This is done on the Compile Menu.
     However, the default in the integrated environment is "Debugging code" on.
     Let's take a look to be sure:

          TYPE-->        <Alt><c>

     The compile menu should pop open, and you should see a check mark next to
     the "Debugging code" option.  If you don't, press the letter "D", and a
     check mark should appear.  Once you've verified that the option is on, we
     can compile the program.  Notice that there is an <F10> next to the option.
     Instead of opening this menu and selecting the "Compile" option, we could
     have pressed <F10>.  Let's try it.  First, let's close the menu (Function
     keys don't work inside a menu):

          TYPE-->        <ESC>

     The menu should have closed.  Now let's compile using the function key:

          TYPE-->        <F10>

     You should see the compiler screen pop up, and compile the program.  No
     errors should be detected.  Now we're ready to test the program.  First,

                                      Page - 36


     let's set a breakpoint so we can easily view the screen output, Use the
     down arrow key to position the cursor on line 20 (the line number is
     displayed on the ASIC status line).  Line 20 should contain an "END"
     statement.  Let's open the run menu and set a breakpoint:

          TYPE-->        <Alt><r>
                         <b>

     The "END" statement should now be displayed in reverse video.  That tells
     us that a breakpoint has been set there.  Did you notice that the
     breakpoint option on the menu also had a function key listed.  We could set
     a breakpoint without opening a menu, by pressing <F9> instead.  Now that
     we've set a breakpoint, let's run the program and see how it works:

          TYPE-->        <Alt><r>
                         <r>

     Note that we could have pressed the short cut key of <F5> to run the
     program instead of selecting the option from the menu.  At this point our
     program is running, but is paused at the breakpoint we set on line 20.
     When you reach a breakpoint, ASIC will position the breakpointed line on
     the second line of the edit window, highlighted in red (or underlined, if
     you have a monochrome system). ASIC has interrupted the program before it
     executed the line with the breakpoint, in this case "END".  Let's take a
     look at the screen output of the program to see if it worked:

          TYPE-->        <Alt><r>
                         <s>

     Note we could also select the "Swap" function by pressing <F4> without
     opening a menu.  You should now see the output from the program on the
     screen.  It should look something like:

     Original Scores:
         55    33   877    99    44   101    21    88   105     1
     Sorting...
     Here are the sorted scores:
         33    55    99    44   101    21    88   105     1   877

     Well, that doesn't look quite right.  Maybe we can use the debugger to
     figure out what went wrong.  First, let's allow the program to run to
     completion (remember, we're paused at a breakpoint on the "END" statement).
     Swap back to the ASIC screen from the user screen by pressing any key:

          TYPE-->        <enter>

     You should see the editor screen again.  Now let's tell ASIC to resume
     program execution:

          TYPE-->        <Alt><r>
                         <r>



                                      Page - 37


     ASIC has executed the END statement, and our program has terminated.  You
     should see the message "Program Terminated Normally (0)".  (The "0" is the
     return code set by the program.  You can set return codes in your programs
     using the END statement.  Refer to Chapter 7 for details.).  Now we'll set
     another breakpoint in the program.  Move the cursor to line 7 (the status
     line should now say LINE: 7) using the arrow keys.  The cursor should now
     be positioned on the statement which says:  PRINT "Sorting...".  Set a
     breakpoint here:

          TYPE-->        <F9>

     The source statement should now appear in reverse video.  We used the
     shortcut key <F9> to set the breakpoint this time, but you could have
     opened the Run Menu, and selected the Breakpoint option and done the same
     thing.  Let's remove the breakpoint:

          TYPE-->        <F9>

     Line 7 should no longer be highlighted.  The same command is used to turn
     breakpoints on or off for a source line.  ASIC just checks to see if a
     breakpoint is already set at that source line when you select the
     breakpoint command.  If one is set, it "toggles" it off (i.e. removes it),
     otherwise, it "toggles" it on (i.e. sets a breakpoint).  This exercise was
     just to show you how to remove a breakpoint, let's go ahead and set it
     again:

          TYPE-->        <F9>

     Line 7 should be highlighted again (the breakpoint is set).
     It might be nice to see what's in some of our program's variables, so let's
     "watch" some variables.  Open the Run Menu, select the Watch command, and
     tell ASIC you want to watch variable "I".

          TYPE-->        <Alt><r>
                         <w>
                         i<enter>

     ASIC should have opened a "Watch" window at the bottom of the screen.  You
     should see the variable name "I" at the left, followed by a ":".  Following
     the ":" is the current value of that variable.  The number there now
     doesn't really mean anything, since our program is not running.  But once
     the we start the program, this number should represent the actual value of
     the variable "I".

     Let's watch a few more variables: j, j1, and scores(1).  This time, we'll
     use the shortcut key for the watch command:

          TYPE-->        <F6>
                         j<enter>

     Variable "J" should now be in the watch window.

          TYPE-->        <F6>

                                      Page - 38


                         j1<enter>

     Variable "J1" should now be in the watch window.  When we watch  "scores",
     we'll also have to tell ASIC which element we want to watch by entering a
     subscript, since "scores" is an array.  First ASIC will prompt you for the
     variable name.  Type it, without the subscript.  ASIC will prompt you for
     the numeric subscript.

          TYPE-->        <F6>
                         scores<enter>
                         <1><enter>

     Scores(1) should now be in the watch window.  Now we're ready to run the
     program again:

          TYPE-->        <F5>

     Again we selected the short cut key, you could have selected the "Run your
     program" option from the "Run" Menu.  The second line of the edit screen
     should show the PRINT "Sorting..." statement (highlighted in red, or
     underlined if you have a monochrome monitor).  The variables in the watch
     window should have the following values:

          I:    11
          J:     0
          J1:     0
          SCORES(1):    55

     Let's execute the next statement by using the Trace command:

          TYPE-->        <Alt><r>
                         <t>

     ASIC has executed the PRINT "Sorting..." statement and has paused execution
     on the "FOR I" statement on line 8 of the program.  Since the PRINT
     statement did not modify any variables, the numbers in the watch window
     should remain unchanged.  Let's Trace one more statement, this time, we'll
     use the short cut key:

          TYPE-->        <F8>

     ASIC has executed the "FOR I" statement on line 8, and is now paused on
     statement "FOR J" on line 9 of the program.  Something looks wrong though.
     Even though we executed the first "FOR I" statement, the variable "I" still
     contains "11".  It should contain "1".  If you look at line 8, you'll see
     that the FOR statement was mistyped, it reads:  "FOR I = I to 9", instead
     of "FOR I=1 to 9".  Since the program also used variable "I" to READ the
     data into the array, "I" still contains the value "11".  Since "11" is
     greater than the "TO" value of the "FOR" loop, the FOR loop on line 8 is
     executed only 1 time instead of 9 times.  That's why the data is not being
     fully sorted.  With the ASIC debugger, we can continue testing without
     recompiling, by modifying the value of "I" to "1", so we can see if the
     rest of our logic is correct.  If changing "I" to "1" works, then we can go

                                      Page - 39


     back and modify the "FOR" statement and recompile the program to correct
     the program permanently.  Modify the value of "I" to "1":

          TYPE-->        <Alt><r>
                         <m>
                         i<enter>
                         <1><enter>

     The watch window should now show the value of "I" as 1.  We can resume
     program execution at this point by selecting the "Run your program" option.
     We'll use the short cut key again:

          TYPE-->        <F5>

     ASIC should pause the program at the next breakpoint, which is on line 20.
     This statement contains the "END" command.  Now let's see if the program
     worked, by swapping to the user screen:

          TYPE-->        <F4>

     Again, we used the short cut key.  You should see the following on your
     screen:

     Original Scores:
         55    33   877    99    44   101    21    88   105     1
     Sorting...
     Here are the sorted scores:
          1    21    33    44    55    88    99   101   105   877

     It looks like the program worked.  Let's return to the editor screen.

          TYPE-->        <enter>

     Now we could press <F5> to resume execution and in this case terminate,
     since the END statement is the next one to execute.  But let's look at
     another way to terminate a program.  While at a breakpoint, you can select
     the "Abort your program" option, which instructs ASIC to terminate your
     program immediately, without executing any more of your program.  Let's try
     it:

          TYPE-->        <Alt><r>
                         <a>

     ASIC should display the message "Program Terminated Normally (0)".  At this
     point, we'll just exit from ASIC, but normally, you would fix the FOR
     statement using the editor, save the file, recompile the program, and
     retest it to make sure the "bug" is really fixed.

          TYPE-->        <Alt><f>
                         <x>

     You should be back at the DOS prompt now.  That concludes the brief
     introduction to the ASIC debugger.  The rest of this chapter provides some

                                      Page - 40


     additional reference material for the debugger.  Chapter 3 provides
     additional information about each of the debugging commands.


                                    DEBUGGER TIPS

     1)  WHEN YOU ARE DONE DEBUGGING YOUR PROGRAM, YOU SHOULD RECOMPILE
         WITH THE "DEBUGGING CODE" OPTION TURNED OFF. Although your program
         can run from the DOS command line with debugging code present, it
         will increase the program size and execution times.  Recompiling
         with the "Debugging code" option off will insure your programs
         will be smaller and faster.

     2)  Remember that the default option on the command line compiler is
         "Debugging code" off.  The default option in the integrated
         environment is "Debugging code" on.

     3)  Breakpoints/Watches are automatically cleared when you
         OPEN or COMPILE a file.

     4)  If you change source lines in a program while a program
         is running, without recompiling, source statements will
         not match executable code.  Abort the running program
         and recompile after making code changes.

     5)  Breakpoints are set in the edit buffer relative to the
         beginning of the buffer.  If you insert/delete lines in
         the buffer, the breakpoints will still be set at the
         same relative line number from the beginning of the
         buffer.

     6)  ASIC takes over the INT 3 Interrupt vector for debugging
         purposes. It re-installs the default vector when you
         exit ASIC.

     7)  You must compile with the "Debugging code" option to use
         source level debugging.

     8)  If you wish to run a program from the beginning again
         while its already running,  select the "Abort your
         program" option from the Run menu.  Then, select the
         "Run your program" option.

     9)  If you select the Abort option from the Run menu, your
         program's files will NOT be closed gracefully.  That
         is, data in the buffers will not be flushed to disk.

     10) You may still run a program in the integrated environment that
         has been compiled without the Debugging code option.  You just
         won't be able to use the debugging commands (e.g.,
         Breakpoints/Watches).

     11) Toggling a breakpoint on/off will clear any block of

                                      Page - 41


         text you had previously marked for editing (e.g., MOVE,
         COPY).

     12) When modifying array variables, make sure that the
         subscript you specify is valid.  For example, if you
         "DIM A(10)", make sure the subscript you specify is in
         the range of 0 to 10.  ASIC does not check the range of
         a subscript.  If you specify a subscript that exceeds
         the valid range for that variable, your program may
         crash.

     13) You can pass arguments to programs using the "Arguments"
         option on the Run Menu.  You may retrieve these options
         in your program with the COMMAND$ statement.  Using the
         "Arguments" option is equivalent to specifying arguments
         following the program name, when you run your program
         from the DOS command line.

     14) The compiler allows variable names up to 80 characters in
         length.  The debugger only uses the first 30 characters of a
         variable name.  When the debugger finds two variables whose names
         are not unique within 30 characters, it will always select the
         first one it finds (this applies to the Watch/Unwatch/Modify
         Variables commands).

     15) ASIC will allow you to set a breakpoint on a "FOR" statement.
         However, you should be aware that the source statement containing
         the "FOR" is executed only once (to initialize the loop).  When
         the "NEXT" statement executes, control transfers back to the line
         following the "FOR", instead of the "FOR".  For example, in the
         following code fragment:

          FOR I = 1 TO 3           <---Executes 1 time to initialize loop
               PRINT I             <---Executes 3 times
               A=A+1                    <---Executes 3 times
          NEXT I                   <---Executes 3 times, loops back to
                                       "PRINT I", not to "FOR I= 1 TO 3"

     16)  Because a single machine language instruction could span multiple
          CODE statements, ASIC does not allow breakpoints on CODE
          statements.













                                      Page - 42


                                       A S I C

                                      Chapter 5

                            Command Line Compiler Options


                                 COMMAND LINE SYNTAX


     Invoke the command line version of the compiler as follows:

          ASICC filename option1 option2 option3[...optionN]
                    or
          ASICC filename.PRJ option1 option2 option3[...optionN]

          Where:  filename    is the name of the source program or project file
                              to be compiled.  Source files must have the file
                              extension ".ASI", although the extension may be
                              omitted from the command line.

          filename.PRJ        Project files may be specified instead of a source
                              file name.  These have a ".PRJ" extension, and the
                              ".PRJ" extension must be typed if you want ASIC to
                              use the project file for the compile. Specifying a
                              project file tells ASIC to look for a project file
                              (created by the integrated environment), and use
                              the options from this file during the compile.
                              ASIC will then strip off the ".PRJ" extension and
                              try to compile a file with the same filename as
                              the ".PRJ" file, but with a ".ASI" extension.

          optionN             specifies any options desired.  No options are
                              required, but more than one can be specified as
                              long as you insert a space between each one.


                                  COMPILER OPTIONS

     The following compiler switches are currently available for ASIC:

     Switch         Description

     B/xxx          BUILD--Use this option to specify the type of output file
                    ASIC is to produce.  The "xxx" on this option should be one
                    of the following:

                    xxx= COM       <--produce .COM file
                         EXE       <--produce .EXE file
                         OBJ       <--produce .EXE file via OBJ file
                                        using DOS LINK command
                                        optionally linking with
                                        other OBJ or LIB files.

                                      Page - 43



                    Default:  ASIC will generate a ".COM" output file.

     C              CONTINUE--ASIC will not pause after messages are issued, but
                    will continue compiling.

                    Default:  ASIC will pause after each error message.
                    Compilation will resume after you press a key.

     D              DISKLIST--ASIC will echo all screen messages to a disk file
                    named "progname.LST".  The format is the same produced by
                    PRINTLIST.  This allows you to compile at higher speed, and
                    print the source listing later from the disk file via the
                    DOS print spooler.

                    Default:  ASIC does not produce a ".LST" file.

     DEC            DECIMAL MATH--ASIC will enable the Decimal Math Option.
                    When this option is selected, you may specify decimal
                    numbers (e.g., BALANCE@, 123.456789, etc.) which can hold
                    numbers in the range +/-999,999,999,999.99999.  This option
                    does increase the size of your ".COM" or ".EXE" file.

                    Default:  ASIC does not enable the Decimal Math Option.

     E              EMATH--ASIC will enable the Extended Math Option.  When this
                    option is selected, you may specify long integers (e.g.,
                    VELOCITY&, 123456789&, etc.) which can hold a larger range
                    of values (+2,147,483,647 to -2,147,483,647).  This option
                    does increase the size of your ".COM" or ".EXE" file by a
                    couple of hundred bytes.

                    Default:  ASIC does not enable the Extended Math Option.

     L              LIST ALL--ASIC will list each source line as it compiles it.

                    Default:  ASIC will list only source lines with compile
                    errors.

                    Comment:  Use of this switch will slow compile speeds
                    slightly due to the additional screen I/O.

     LIB=xxx        LINK LIBRARY--Specifies libraries that ASIC should pass to
                    the DOS LINKer.  This option is ONLY used by ASIC when you
                    compile with the "B/OBJ" option.  It is ignored when you
                    compile with the "B/COM" or "B/EXE" options.  A link library
                    is usually used to store commonly used subroutines in OBJECT
                    format.  You can create assembly language subroutines for
                    ASIC, and store them in a library using the Borland TLIB
                    Program or the Microsoft LIB Program.  The "xxx" should
                    specify one or more library file specs with each library
                    spec separated with a "+" character.  See Chapter 10 of the
                    ASIC manual for more information.

                                      Page - 44



                    Examples:

                         LIB=C:\ASIC\MATH.LIB
                         LIB=C:\DOS\MISC.LIB+C:\LIB\COMMON

                    The first example shows a single library spec for MATH.LIB
                    library.  The second example shows how to include more than
                    one library--MISC.LIB and COMMON.LIB libraries.

                    Comments:  When specifying libraries, you may omit the file
                    extension, if it is ".LIB".



     LNK=xxx        LINKer LOCATION--Specifies the location of the DOS LINK.EXE
                    program to ASIC.  This option is ONLY used when compiling
                    with the "B/OBJ" option. Unless the LINK.EXE which is
                    provided with MS DOS is located in the default ASIC
                    directory, ASIC may not be able to locate the program, and
                    will thus be unable to LINK your program to create a ".EXE"
                    file.  The LINK.EXE should be included on your MS DOS
                    distribution disks (if it is not already in your DOS
                    directory). "xxx" should specify a file path.  For more
                    information on this option see Chapter 10 of the ASIC
                    Manual.

                    Example:

                         LNK=C:\DOS3

                    Default:  By default, ASIC will attempt to locate the linker
                    in the default directory.  If it can't find the LINK.EXE
                    file there, it tries to find it under the "C:\DOS"
                    directory.  If it can't find it there, it gives up and
                    issues an error message.

     OBJ=xxx        ADDITIONAL OBJECT FILES--Specifies a list of additional
                    object files that ASIC should link with the main object
                    file.  This option is ONLY used by ASIC when you are
                    compiling with the "B/OBJ" option.  You do not need to
                    include the name of your ASIC program here, that is done
                    automatically by ASIC.  When you compile with this option,
                    ASIC creates an OBJ file which can be linked using the DOS
                    LINKer.  Optionally, you can included "CALL SUB" statements
                    in your program which reference separately compiled OBJ
                    files.  This option allows you to pass other object file
                    names to the DOS LINKer to resolve these external
                    references.  The "xxx" parameter should include file specs
                    for one or more object files with a "+" character separating
                    each object file.  See Chapter 10 of the ASIC Manual for
                    more details.


                                      Page - 45


                    Examples:

                         OBJ=C:\ASIC\MYSUB.OBJ
                         OBJ=C:\LIB\SUB1.OBJ+C:\OBJ\SUB2

                    The first example specifies a single object to be passed to
                    the linker.  The second example illustrates two object
                    files: SUB1.OBJ and SUB2.OBJ.

                    Comments:  The file extension may be omitted if it is
                    ".OBJ".

     P              PRINTLIST--ASIC will echo all messages which appear on the
                    screen to the printer. Output to the printer will be paged
                    with header lines identifying the program name, and the
                    date/time compiled.

                    Default:  ASIC will not send any messages to the printer

                    Comments: Even though output to the printer is buffered,
                    this option will slow compile speeds considerably.  The
                    compiler typically compiles only as fast as your printer can
                    print the messages.  An alternative to this switch is the
                    DISKLIST option.

     S              SYMTAB--ASIC will produce a formatted Symbol Table in a file
                    named "progname.SYM".  The symbol table contains a list of
                    all variables, labels, and internally created compiler
                    addresses.

                    Default:  ASIC does not produce a ".SYM" file.

     STK=n          STACK SIZE--Specifies the size of the stack that you wish
                    ASIC to create.  This option is ignored when you are using
                    the "B/COM" option.  "n" equals the size of the stack you
                    want in bytes.

                    Default:  By default, ASIC sets the stack size to 2000 bytes
                    (4000 bytes if you are compiling with debugging mode).

                    Examples:

                         STK=512

                    In the above example, the stack size would be set to 512
                    bytes.

                    Comments:  The default stack sizes that ASIC provides are
                    normally adequate, however, they may be larger than your
                    program may need.  If you are interested in minimizing your
                    program's memory usage, you may experiment with the STK
                    option, however, setting the size too small can cause
                    unpredictable results.  This option is recommended only for

                                      Page - 46


                    experienced ASIC users.  The stack size must be in the range
                    16 to 32767.  ASIC will not allow you to create a stack size
                    smaller than 4000 bytes when compiling with debugging mode
                    on.  If you specify a smaller value in this instance, ASIC
                    will override it with a size of 4000.

     X              DEBUG--ASIC will generate debugging code in the ".COM" or
                    ".EXE" file and a ".DBG" file for use by the integrated
                    environment debugger.

                    Default:  ASIC does not generate debugging information.

                    Comment:  If you are running from the integrated
                    environment, ASIC sets this option on by default.  You may
                    turn it off in the Compile menu, should you so desire.


                                  COMPILE EXAMPLES

     Example 1:     Compile "MYFILE.ASI" with default compiler options:

                    ASICC MYFILE

     Example 2:     Compile "MYPROG.ASI", Listing all source lines, writing a
                    compile listing to a disk file for printing later.  The
                    listing file will be called "MYPROG.LST":

                    ASICC MYPROG L D

     Example 3:     Compile "FILEX.ASI", don't pause for any errors, and print
                    the errors on the printer:

                    ASICC FILEX C P

     Example 4:     Compile "CRUNCH.ASI" and allow long (32 bit) integer
                    numbers:

                    ASICC CRUNCH E

     Example 5:     Compile "BIGPROG.ASI" and create a ".EXE" format output
                    file:

                    ASICC BIGPROG B/EXE

     Example 6:     Compile "SAMPLE.ASI" and create a ".EXE" format output file,
                    with a stack size of 2500 bytes.

                    ASICC SAMPLE B/EXE STK=2500

     Example 7:     Here's a more complex example, which demonstrates the   use
                    of the B/OBJ build options.  Assume we have a program called
                    "MAIN.ASI" which calls three assembly language subroutines,
                    called "A", "B", and "C".  Subroutine "A" is stored in file

                                      Page - 47


                    "A.OBJ".  Subroutines "B" and "C" are stored in a library
                    called "ASMSUB.LIB".  The DOS LINK.EXE file is contained in
                    the subdirectory "C:\UTIL".  Here is the ASICC command to
                    compile MAIN.ASI and link in the subroutines called using
                    "CALL SUB" in the MAIN.ASI program:

                    ASICC MAIN B/OBJ OBJ=A LIB=ASMSUB LNK=C:\UTIL


                                PROGRAM PROJECT FILE

     The ASIC integrated environment automatically stores compile options for
     each program in a file called "progname.PRJ".  Whenever you compile from
     the integrated editor, ASIC will always check for this file, and set
     compile options based on the file.

     Since MS DOS has a restriction of 128 characters for a command line, you
     may find it useful to use the integrated environment to set your compile
     options for a program, even if you are not using the environment for
     editing.  This is especially true when you are using the "B/OBJ" option,
     where you frequently may be passing many parameters.  Then, you may type
     the program project file name instead of the program source file name when
     compiling from the command line and ASIC will use the options from the
     ".PRJ" file for that compile.

     You may still specify additional compile line options when compiling using
     the ".PRJ" file option.  In this case, the option from the command line
     will override any corresponding option from the ".PRJ" file.

     Although the ".PRJ" file is a standard DOS text file, it is recommended
     that you not edit this file using a text editor--if incorrectly modified,
     compiler results may be unpredictable.

     Example:

          ASICC myfile.prj LIB=NEWLIB

     In this example, all options set in the "MYFILE.PRJ" file will be read and
     used by the ASIC command line compiler, except for the "LIB" option which
     was specified on the command line.  For this compile, ASIC will set the LIB
     option to "NEWLIB" regardless of what the LIB option was set to in the
     project file.  ASIC will then try to compile a source file called
     "MYFILE.ASI".











                                      Page - 48


                                       A S I C

                                      Chapter 6

                                  Language Elements


                                    CHARACTER SET


     Symbol         Description

       *            Multiplication
                    Example: A=B*C  (multiply B by C, store result in A)

       /            Division
                    Example: A=B/C  (divide B by C, store result in A)

       +            Addition
                    Example: A=B+C  (add C to B, store result in A)

       +            String Concatenation
                    Example: A$="AB"+"C"   (A$ will contain "ABC")

       =            Assignment
                    Example: A=1    (A will be assigned the value 1)

       =            Equality testing
                    Example: IF A=1 THEN QUIT:  (If the value stored in
                    A equals 1 goto label QUIT)

       <            Less than testing
                    Example:  IF A<1 THEN QUIT:  (If the value stored in
                    A is less than 1 goto label QUIT)

       <=           Less than or equal to testing
                    Example:  IF A<=1 THEN QUIT:  (If the value stored in
                    A is less than or equal to 1 goto label QUIT)

       <>           Inequality testing
                    Example:  IF A<>1 THEN QUIT:  (If the value stored in
                    A is not equal to 1 goto label QUIT)

       >            Greater than testing
                    Example:  IF A>1 THEN QUIT:  (If the value stored in
                    A is greater than 1 goto label QUIT)

       >=           Greater than or equal to testing
                    Example:  IF A>=1 THEN QUIT:  (If the value stored in
                    A is greater than or equal to  1 goto label QUIT)

       -            Subtraction
                    Example: A=B-C   (Subtract C from B, store result in A)

                                      Page - 49



       "            String Delimiter
                    Example: A$="the string is inside quote marks"

       ()           Parenthesis -- Ignored by ASIC

       ;            Suppress Carriage Return/Line Feed with PRINT/LPRINT

       #            Used to identify file usage with PRINT#/INPUT#

       ,            Comma,  Ignored by ASIC

       $            Distinguishes a String Variable from an Integer.
                    Example:    ABC$   <---- String Variable
                    Example:    ABC    <---- Integer Variable

       :            Distinguishes a Label from a variable name.
                    Example:    START:    <---Label name

       &            Distinguishes a "long" (32 bit) integer from a normal
                    integer (16 bit) variable or constant.  Normal integers
                    can hold numbers in the range +32,767 to -32,767.  Long
                    integers can hold numbers in the range +2,147,483,647
                    to -2,147,483,647.  Note:  You must compile with the
                    "Extended Math" Option enabled to use long integers.
                    Example:    APPLES&   <--Long Integer Variable
                    Example:    ORANGES   <--Normal Integer Variable
                    Example:    123457&   <--Long Integer Constant
                    Example:    1234      <--Short Integer Constant

       @            Distinguishes a "decimal" (64 bit) variable or constant
                    from a normal integer (16 bit) variable or constant.
                    Decimal numbers can be in the range
                    +999,999,999,999.99999 to -999,999,999,999.99999.  Note:
                    You must compile with the "Decimal Math" option enabled
                    to use decimal numbers.
                    Example:  APPLES@   <--Decimal Variable
                    Example:  1234.567  <--Decimal Constant
                    Example:  123@      <--Decimal Constant
                    Example:  1.2@      <--Decimal Constant


                          CONSTANTS, VARIABLES, AND LABELS

     ASIC supports the following data types:

          Decimal Constants        Integer Constants
          Decimal Variables        Integer Variables
          Decimal Arrays           Integer Arrays

          String Constants         Long Integer Constants
          String Variables         Long Integer Variables
          String Arrays            Long Integer Arrays

                                      Page - 50



     Integer constants may be specified in decimal (base 10), hexadecimal (base
     16), or binary (base 2).  The following describes the restrictions for each
     data type.

     DECIMAL CONSTANTS        Range     +999,999,999,999.99999 to
                                        -999,999,999,999.99999

                         Example:        105.1

     DECIMAL VARIABLE    Described by a variable name beginning with a
                         letter, followed by up to 78 additional letters,
                         underscores, or numbers, terminated with an "@"
                         symbol.  It may contain a number in the range of
                         +/-999,999,999,999.99999

                         Example:       INTEREST@
                         Example:       PAY_RATE_1@

     DECIMAL ARRAY       Described by a variable name beginning with a
                         letter, followed by up to 78 additional letters,
                         underscores, or numbers, terminated by an "@" symbol.
                         This is followed by an integer variable or constant
                         for the dimension of the array.  Arrays must be
                         dimensioned at the beginning of the program.  See
                         the DIM statement.

                         Example:       SALES@(YEAR)

     INTEGER CONSTANTS        Range  +32767 to -32767

                         Example:       -26

     INTEGER VARIABLE    Described by a variable name beginning with a
                         letter, followed by up to 79 additional letters
                         underscores, or numbers.  It may contain a number in
                         the range +32767 to -32767.

                         Example:       VELOCITY1

     INTEGER ARRAY       Described by a variable name beginning with a
                         letter, followed by up to 79 additional letters,
                         underscores, or numbers.  This name is followed by an
                         integer variable or constant for the dimension
                         of the array.  Arrays must be dimensioned at the
                         beginning of the program.  See the DIM statement.

                         Example:       GROWTH (YEAR)

     LONG INTEGER        Range  +2,147,483,647 to -2,147,483,647
     CONSTANTS
                         Example:       3234457&


                                      Page - 51


     LONG INTEGER        Described by a variable name beginning with a
     VARIABLE            letter, followed by up to 78 additional letters,
                         underscores, or numbers terminated with a "&".  Can
                         contain numbers in the range +2,147,483,647 to
                         -2,147,483,647.

                         Example:       VELOCITY1&

     LONG INTEGER        Described by a variable name beginning with a
     ARRAY               letter, followed by up to 78 additional letters,
                         underscores, or numbers, terminated with a "&".  This
                         name is followed by an integer variable or constant
                         for the dimension of the array.  Arrays must be
                         dimensioned at the beginning of the program.
                         See the DIM statement.

                         Example:       GALAXY& (BILLIONSOF)

     HEXADECIMAL         Hexadecimal constants are constants which are
     CONSTANT            stated in base 16 instead of base 10 like normal
                         constants.  These may be specified wherever you
                         can specify a integer constant.  Hexadecimal
                         constants in ASIC must be prefixed by "&hex". This
                         prefix should be immediately followed by a valid
                         normal or long integer constant.  Hex constants
                         may contain up to 8 hexadecimal digits for long
                         constants, and 4 hexadecimal digits for normal
                         constants.

                         Example:  &hexB000  <--equivalent to -20400
                         Example:  &hexB&     <--equivalent to 11&
                         Example:  &hexFFFFFFFF&  <--equivalent to -1&
                         Example:  &hexB000&  <--equivalent to 45056&

     BINARY CONSTANT     Binary constants are constants which are stated in
                         base 2 instead of base 10 like normal constants.
                         These may be specified wherever you can specify a
                         integer constant.  Binary constants in ASIC must
                         be prefixed by "&bin".  This prefix should be
                         immediately followed by a valid normal or long
                         integer constant.  Binary constants may contain
                         up to 32 binary digits for long constants or 16
                         binary digits for normal constants.

                         Example:  &bin10         <--equivalent to 2
                         Example:  &bin10101011&  <--equivalent to 171&

     STRING CONSTANT     A group of 0-80 characters enclosed by quotation
                         marks.

                         Example:       "This is a String Constant"

     STRING VARIABLE     Described by a variable name which begins with a

                                      Page - 52


                         letter, followed by up to 78 additional letters or
                         underscores, or numbers, terminated with a "$".
                         Can contain 0-80 characters.

                         Example:       ADDRESS$

     STRING ARRAY        Described by a variable name which begins with a
                         letter, followed by up to 78 additional letters,
                         underscores, or numbers, followed by a $, followed by
                         an integer variable or constant enclosed in
                         parenthesis representing the subscript.  Arrays must
                         be dimensioned at the beginning of the program.
                         See the DIM statement.

                         Example:       STATE$(50)

     LABEL               A Label is a location in your program you wish
                         to transfer to.  It must begin with a letter,
                         and it may contain up to 78 additional letters
                         or numbers.  It must be terminated with a ":".

                         Example:       START:


                               VARIABLES VS. CONSTANTS

     In general, ASIC will allow the use of either variables, arrays, or
     constants as operands to any program statement.  For example:

                    PRINT CASH
                    PRINT 20
                    PRINT A(10)

     All three of the above examples are valid.  The only case where a constant
     cannot be used, is where the value is being modified.  For example:

               A = A + B      <----VALID
               17 = A + C     <----INVALID

     Of course you must specify the correct data type for the ASIC keyword.
     For example:

               A = ABS("HELLO")    <----INVALID

     This statement is invalid because you cannot take the absolute value of a
     string!

     There are a few ASIC statements which will accept only integer constants
     for some operands (DIM, OPEN, PRINT#, INPUT#).  Refer to the individual
     statement for more information.

     There is a restriction on the use of subscripts for Arrays.  A subscript
     for an array cannot be another array,.  For example:

                                      Page - 53



               A(I(1))             <----INVALID
               A(I)                <----VALID

     Finally, decimal variables or constants cannot be used as subscripts:

               A@(1.1)             <----INVALID
               A@(B@)              <----INVALID
               A@(1)               <----VALID
               A@(A)               <----VALID
               A@(A&)              <----VALID


       CONVERSION BETWEEN NUMERIC FORMATS (INTEGER, LONG INTEGER AND DECIMAL)

     Decimal numbers, long integers, or normal integers may be used on any ASIC
     statement in any combination.  Consequently, in the "Keyword Reference"
     Chapter of this is manual, operands are identified only as "number".
     "Number" in this context should be interpreted as meaning that the operand
     for that statement can be any of the following: integer constant, integer
     variable, integer array, long integer constant, long integer variable, long
     integer array, decimal constant, decimal variable, or decimal array.
     Exceptions, if any, are noted in the documentation for the statement.

     If you do mix decimal number, long integers, or regular integers in a
     statement, you should be aware of how ASIC converts between the formats.
     The following rules apply:

          1)  If a long integer variable or constant is being stored in a
              normal integer variable, the long integer (32 bit) number
              will ALWAYS convert correctly to a normal integer (16 bit)
              value provided the long integer variable contains a number
              which will fit in a normal integer (i.e., within the range of
              +32767 to -32767).  If, however, the number is outside of
              this range, ASIC will truncate it to make it fit in a normal
              integer.  This truncation will cause some surprising (but
              predictable) answers.  For example if "A&" contained the
              value "50000&", and the following ASIC statement was executed
              "A=A&", then the value of "A" would be "-15536".  The reason
              that the overflow results in such a strange number is due to
              the way the IBM PC stores numbers in binary format and is too
              complicated to describe here.  The important thing
              to remember is, for ASIC to convert from long integers to
              normal integers correctly, the value in the long integer
              should be in the range of +32767 to -32767.

          2)  If a normal integer variable or constant is being stored in
              a long integer variable, ASIC will always convert the number
              correctly.

          3)  If a decimal number is stored in a normal or long integer, the
              fractional component of the number will be discarded, and the
              remaining integer value will be stored in the normal or long

                                      Page - 54


              integer.  The result will be truncated if necessary to fit.
              For example, after the statement "A=12345.67890" is executed,
              variable "A" would contain the value "12345".  As another
              example, after the statement, "A=50000.12345" is executed,
              variable "A" would contain the value "-15536".  The reason
              that the overflow results in such a strange number is due to
              the way the IBM PC stores numbers in binary format and is too
              complicated to describe here.  The important thing
              to remember is, for ASIC to convert from decimal numbers to
              integers correctly, the value of the decimal number should be
              within the range for the target variable type.

          4)  If a long or normal integer is stored in a decimal variable,
              ASIC will always convert the number correctly.

          5)  IMPORTANT NOTE:  When performing math with a mixture of decimal
              and integer variables, ASIC automatically converts the operands
              to the storage type of the result BEFORE computing the result,
              and the math function called will be based on the variable type
              of the result.  GWBASIC/BASICA floating point, on the other
              hand, converts the operands to the most precise format of the
              operand types to the RIGHT of the equal sign and compute the
              results based on the longest type to the right of the equal
              sign, before scaling the result.  This can be illustrated with
              the following examples:

               ASIC                     GWBASIC/BASICA

               A@=2*2.6 = 5.2           A#=2%*2.6 = 5.2
               B=2*2.6= 4               B%=2%*2.6 = 5
               B&=500 * 500=250000      B&=500% * 500%= OVERFLOW
               B&=500& * 500&=250000    B&=500& * 500&=250000






















                                      Page - 55


                                       A S I C

                                      Chapter 7

                                  Keyword Reference


                                         ABS

     Format:        number1 = ABS (number2)

     Description:

     This function returns the absolute value of number2 which is then stored in
     number1.

     Example:

               A = ABS (-7)

     After execution of this statement, "A" will contain 7.


                                         ASC

     Format:        number1 = ASC (string1)

     Description:

     This function returns the ASCII value of the first character of string1,
     storing the result in number1.

     Example:

               A = ASC("123")

     After execution of this statement "A" would contain 49, which the is ASCII
     value of "1".
















                                      Page - 56


                                        BEEP

     Format:        BEEP

     Description:

     This statement will cause a short "beep" to be produced on the PC speaker.

     Example:

               IF A>99 THEN
                    BEEP
                    PRINT "Number is too big!"
                    A=99
               ENDIF

     The preceding program fragment will check to see if variable "A" contains a
     value less than 100.  If it does not, it will produce a short "beep",
     display a message, and set the value of "A" to 99.



































                                      Page - 57


                                        BLOAD

     Format:        BLOAD string1, number1, number2

     Description:

     This function loads data previously saved by BSAVE from a file to memory.
     String1 should be the name of the file previously created by BSAVE.
     Number1 should be the memory offset to load the data to.  Number2 should be
     the number of bytes to read from the file (in the range of 1 to 32767).  If
     DEFSEG has been set, it will be used as the data segment, otherwise, the
     default ASIC data segment will be used.

     Example:

               DEFSEG = &hexB800
               BLOAD "SAVED.DAT" 0 100

     After execution of these statements 100 bytes will be read from the file
     "SAVED.DAT" and stored in memory start at 0 bytes from the start of the
     override data segment (which in this case happens to point to the beginning
     of video memory for a CGA card).  Assuming a CGA card was present, the
     first 50 characters on the screen would contain data read from the file
     (don't forget that each screen character is represented by two bytes data
     and attribute, that's why only 50 characters will be displayed, assuming
     you are not in graphics mode).

     Comments:

     THIS FUNCTION IS RECOMMENDED ONLY FOR ADVANCED PROGRAMMERS.  THIS STATEMENT
     WILL ALLOW YOU TO OVERLAY ANY AREA OF MEMORY, AND IT IS VERY EASY TO
     ACCIDENTALLY OVERLAY YOUR PROGRAM OR THE MEMORY USED BY DOS.

     If ASIC detects an error executing this command, it will set the system
     ERROR variable.  These error codes are listed in the Error Messages Chapter
     of the ASIC Manual.

     This statement is slightly different from GWBASIC/BASICA in that you must
     specify how many bytes to read from the file.  Also, the memory offset is
     not stored in the file by BSAVE, so you must specify the offset as number1
     in ASIC.  Offset is optional in GWBASIC/BASICA.

     ASIC uses a slightly different file format than GWBASIC/BASICA, however, it
     is relatively easy to convert the GWBASIC/BASICA to ASIC format.
     GWBASIC/BASICA files have a seven byte header that ASIC does not have.  If
     you strip off these 7 bytes and rewrite the file, ASIC should be able to
     process the file.

     See also:

          DEFSEG,BSAVE



                                      Page - 58


                                        BSAVE

     Format:        BSAVE string1, number1, number2

     Description:

     This statement writes the block of memory beginning at offset number1 from
     the start of the data segment for a length of number2 bytes to the file
     specified by string1.  This data may be later loaded by BLOAD.  If DEFSEG
     has been set, it will be used as the data segment, otherwise, the default
     ASIC data segment will be used.
     Number2 should be in the range of 1 to 32767.

     Example:

               DEFSEG = &hexB800
               BSAVE "SAVED.DAT" 0 4000

     After execution of these statements 4000 bytes at offset 0 bytes from the
     start of the override data segment (which in this case happens to point to
     the beginning of video memory for a CGA card) will be written to the file
     "SAVED.DAT".  Assuming a CGA card was present, the current screen would be
     saved to disk, assuming you are not in graphics mode.

     Comments:

     If ASIC detects an error executing this command, it will set the system
     ERROR variable.  These error codes are listed in the Error Messages Chapter
     of the ASIC Manual.

     See also:

          DEFSEG,BLOAD





















                                      Page - 59


                                        CALL

     Format:        CALL (string1,string2)                       <-Format 1
                    CALL SUB (stringconstant1,[arg1,...,argN])   <-Format 2

     Description:

     Depending on the format that you select, this statement can be used to
     perform two different functions.  Format 1 is used to load and execute
     another program (in .EXE, .COM format).  Format 2 is used when you have
     compiled a subroutine in a .OBJ file, and wish to incorporate this routine
     in an ASIC program, and CALL it as a subroutine.  Notice the difference
     between these two approaches.  In format 1, execution of your ASIC program
     is suspended, and a new .EXE or .COM file is loaded from disk and executed.
     When the .EXE or .COM program terminates, your ASIC program resumes
     execution.  With format 2, however, the subroutine itself is bound into
     your ASIC program with the DOS linker, so that when you call it, no disk
     access is required, and the overhead of the call is much lower.

     When using format 1, this statement can be used to load and execute other
     programs compiled with ASIC or another compiler.  String1 represents the
     name of the program to execute.  String2 contains any arguments to be
     passed to the program (it may be NULL, i.e. "").  If an error occurs when
     ASIC attempts to call the program, it will set the system ERROR variable to
     255.  Otherwise, the ERROR variable will be set to the value of the return
     code of the called program (which is 0 unless the called program specifies
     otherwise).

     Format 2 is used to call a separately compiled subroutine, that uses the
     BASIC (or PASCAL) parameter passing conventions.  You could use this to
     call a subroutine that you had written in ASIC or assembler.  When using
     this format,  you must compile using the OBJ output option.  ASIC will
     produce an OBJ format output file, that can be linked with the standard DOS
     linker.  When you compile within the integrated environment, ASIC
     automatically calls the DOS linker for you, when the OBJ option is
     selected.  With this format, stringconstant1 must be a string constant that
     contains the name of the subroutine to be called.  The remaining fields
     (arg1 through argN) are optional, but if specified, they must be variables
     or constants.  These arguments will be passed to the called subroutine
     using the stack.  These arguments will be passed "by reference", which
     means that a pointer to the variable will be passed, instead of the value
     contained in the variable.  This means that the subroutine you call can
     modify the values of the ASIC variables passed. See the SUB and ENDSUB
     statements for information on create OBJ subroutines using ASIC.

     (See Chapter 10 of the ASIC manual, for more information on using format
     2).

     Example 1: (format 1)

               CALL ("MYPROG.COM","")
               REM other code follows


                                      Page - 60


     This statement would cause ASIC to load and execute the program
     "MYPROG.COM".  No arguments will be passed to the program.  When MYPROG
     terminates, the calling program will regain control on the line following
     the call, in this case the "REM" statement.

     Example 2: (format 1)

               CALL ("COMMAND.COM"," /C WP.BAT")

     In this example, a ".BAT" type file is executed called "WP.BAT".  To run
     ".BAT" files, it is necessary to load a copy of COMMAND.COM as shown above
     (COMMAND.COM contains the DOS code required to load and execute ".BAT"
     files).  Using this format, you can also run some "built in" DOS commands
     such as DIR or SORT.  Using CALL with this format, is similar to using the
     GWBASIC/BASICA SHELL command.

     Example 3: (format 2)

               CALL SUB ("mysub",A,A$,1)

     In this example, a subroutine "mysub" is being called.  Three arguments are
     being passed to the subroutine, "A", "A$" and "1".  You must set the
     compiler output option to OBJ, and specify "MYSUB.OBJ" in the LINK options
     subroutine list.  The arguments will be passed to the subprogram on the
     stack in the order:   A,A$,1.

     Comments:

          Format 1:

     If you are compiling with the OBJ output option, you must LINK your program
     from the command line.  This is due to the fact that, by default, LINK.EXE
     will request all available memory for the program.  When your program tries
     to CALL another program, DOS has no memory to allocate for the called
     program and the CALL will fail.  To get around this, use the
     "/CPARMAXALLOC" LINK parameter and run LINK from the COMMAND line.  You
     must estimate how much memory your program needs to load (in 16 byte
     paragraphs).  For example, to limit your program to 32k, use a LINK
     statement such as the following:

               LINK progname /CPARMAXALLOC:2000

     If you fail to specify a large enough value for "/CPARMAXALLOC", LINK.EXE
     will ignore the option and allocate all available memory, so you may have
     to experiment with this parameter to determine the proper setting.

     When using format 1, string1 must contain the FULL pathname of the program
     (ie,"\directory\progname.COM") only if the program is NOT in the current
     directory.  You must include the file extension on the file name (for
     example, use "MYPROG.COM" instead of just "MYPROG", or use "MYPROG.EXE"
     instead of "MYPROG").

     If you wish to pass arguments to the program build it as follows:

                                      Page - 61



               YOURPARM$ = "arguments"
               N = LEN(YOURPARM$)
               A$ = CHR$(N)
               A$ = A$ + YOURPARM$
               B$ = CHR$(13)
               A$ = A$ + B$
               CALL "progname" a$

     The above creates an argument list according to the strict DOS calling
     rules, however, you can just create the arguments in a string, and precede
     them with a leading space.  This will work for arguments up to 32
     characters in length (space character is ASCII 32).  You might want to try
     this short cut first, and only resort to the full formal approach if you
     have problems with it, or need to specify longer arguments:

               CALL "progname" " arguments"

     It is recommended (but not required) that you compile your program using
     the EXE format (instead of the COM format) when your program uses format 1,
     since an EXE program will release more memory when calling the program.
     This will allow you to call a slightly larger program than is possible with
     the COM format.

          Format 2:

     When using format 2 , the following considerations apply.  First, remember
     that the arguments you pass to the subroutine must match the arguments the
     subroutine expects to receive.  For example, if you pass a single integer
     to the subroutine, the subroutine had better expect to receive a single
     integer, or the results will be unpredictable.  Second, since all arguments
     are passed by reference, all arguments can be modified by the called
     routine.  Be aware that if you pass a constant such as "1" to the routine
     and it modifies the value to "2", that ASIC will now use the value "2" for
     the constant value of "1" wherever "1" is referenced your program.  For
     example, suppose you wrote a subroutine called ADD that added the value of
     argument 2 to the value of argument 1 and stored the result in argument 1:

               CALL SUB ("ADD", 1,33)
               PRINT "1=";
               PRINT 1
               END

                    Program output is:

                         1=34

     Instead, you would want to code the program as follows:

               A=1
               CALL SUB ("ADD",A,1)
               PRINT "A=";
               PRINT A

                                      Page - 62


               PRINT "1=";
               PRINT 1
               END

                    Program output is:

                         A=34
                         1=1

     CAUTION:

     IF YOU CALL A ".BAT" FILE AND DO NOT LOAD A COPY OF COMMAND.COM, THE
     RESULTS ARE UNPREDICTABLE (SEE ABOVE FOR AN EXAMPLE OF HOW TO CALL BAT
     FILE).

     You may use the debugger with programs which contain "CALL" statements.
     However, the programs you call should not themselves contain debugging
     code.  For example, if A.ASI calls B.ASI, then make sure you compile B.ASI
     with the "Debugging Code" option OFF before you try to debug program A.ASI.
     Failure to do so will cause the debugger to behave erratically.  This also
     applies to programs you write using other compilers, since they also use
     the same interrupt as ASIC (INT 3).

     See also:

          RUN,COMMAND$,SUB,ENDSUB




























                                      Page - 63


                                        CHDIR

     Format:        CHDIR string1

     Description:

     This statement will change the current directory to that specified in
     string1.  If an error occurs when ASIC executes this command, it will set
     the System ERROR variable.  A list of possible error codes is listed in the
     Error Messages Chapter of the ASIC Manual.

     Example:

          CHDIR "\DOS"
          IF ERROR = 0 THEN NOERROR:

     If Drive "C" was the current drive, then this statement would change the
     current directory to "C:\DOS".

          CHDIR "C:\DOS"

     This statement would change the current directory on drive C to "C:\DOS"
     whether or not drive C is the current drive. It would NOT change the
     default drive to "C".  Note that DOS retains a current directory for each
     disk drive on your computer.

     See also:

          MKDIR, RMDIR


                                        CHR$

     Format:        string1 = CHR$(number1)

     Description:

     This function converts an integer in the range of 0-255 to an
     ASCII character, and stores in string1.

     Example:

               A$ = CHR$(49)

     After execution of this statement, "A$" will contain "1", since "1" is
     represented by ASCII 49.

     Comments:

     If number1 is outside the range 0-255, then the least significant byte of
     the integer is converted to string1.



                                      Page - 64


                                        CLOSE

     Format:        CLOSE number1

     Description:

     This function closes the file number identified by number1.  If an error is
     returned by DOS, the system variable "ERROR" will be > 0.

     Example:
               CLOSE 1
               IF ERROR > 0 THEN CHECKERROR:

     After successful execution of the CLOSE statement, the file previously
     opened as file 1 will be closed.  If an error is returned by DOS, the
     ERROR variable will be set by ASIC to a non-zero value.

     Comments:

     IF YOU FAIL TO CLOSE AN OPEN FILE (WHICH WAS OPENED FOR WRITING), YOU MAY
     LOSE DATA, SINCE FILE I/O IS BUFFERED, AND THE LAST BUFFER MAY NOT HAVE
     BEEN FLUSHED.

     Also, number1 may only be a constant with the value of 1-3.

     See Also:

          OPEN,PRINT#,INPUT#


                                         CLS

     Format:        CLS

     Description:

     This function clears the screen.

     Example:

          CLS

     After execution of the above statement, the screen will be cleared.











                                      Page - 65


                                        CODE

     Format:        CODE number1[,number2...numberN]

     Description:

     This function may be used to insert machine language code directly into
     your program.  Number1 through numberN should be integer constants in the
     range of 0-255.  At least one number must be specified, however, ASIC will
     allow up to 30 per CODE statement.

     Example:
               CODE 205,5

     This statement represent the machine code generated from the assembly
     language statement "INT 5".  INT 5 is the BIOS routine which will print the
     screen to the printer.  After execution of these statements in your
     program, the current screen contents would be printed on your printer.

     Comments:

     THIS STATEMENT IS INTENDED FOR ADVANCED PROGRAMMERS.  THIS STATEMENT IS
     VERY POWERFUL, AND IF YOU DON'T UNDERSTAND MACHINE LANGUAGE YOU COULD
     EASILY CRASH YOUR PROGRAM.

     When you use this statement, be sure to save the contents of the following
     8088 registers if you plan to modify them, and restore them before
     returning to ASIC.  Otherwise the results may be unpredictable.
     Registers:  DS/CS/ES/SS.  Also, make sure you clean up the stack before you
     return (i.e., if you push a value to the stack, make sure you pop it before
     you return to ASIC)  Failure to do so, will almost certainly cause your
     program to crash.

     See also:

          INT86, SETREGS, GETREGS


















                                      Page - 66


                                        COLOR

     Format:        COLOR number1,number2

     Description:

     This function is used to set the foreground and background screen colors.
     The foreground color is specified in number1, the background color in
     number2.

                    Valid Colors:       Foreground          Background
                    --------------      ----------          ----------
                    Black                    0              0
                    Blue                     1              1
                    Green                    2              2
                    Cyan                     3              3
                    Red                      4              4
                    Magenta                  5              5
                    Brown                    6              6
                    White                    7              7
                    Dark Gray                8
                    Light Blue               9
                    Light Green              10
                    Light Cyan               11
                    Light Red                12
                    Light Magenta            13
                    Yellow                   14
                    Bright White             15

               Note:   Colors 8-15 when specified for background color
                         result in blinking text.
     Example:
               COLOR 4,8

     After execution of this statement, future characters written to the screen
     will be Blinking Red on a Black Background.


















                                      Page - 67


                                      COMMAND$

     Format:        string1 = COMMAND$

     Description:

     This statements retrieves any command line arguments that were entered and
     stores them in string1.

     Example:
               If your program was invoked with:       MYPROG XXX

               And if your program MYPROG.ASI contained the following:

                    A$=COMMAND$
                    A$=LTRIM$(A$)
                    IF A$="" THEN
                         PRINT "Enter File Name ";
                         INPUT A$
                    ENDIF
                    OPEN "I", 1, A$


     The above example would open file "XXXX" for input.  If the user had
     invoked the program by typing "MYPROG" with no parameters, then the program
     would prompt for the file name to open.

     Comments:

     In the integrated environment, you can specify command line arguments on
     the "Run" Menu.

     If this statement is used within a SUB/ENDSUB block, the results returned
     by ASIC are unpredictable (i.e., the command tail is not accessible in a
     SUB).

     This statement is an extension over BASICA/GWBASIC.

















                                      Page - 68


                                       COMSTAT

     Format:        number1 = COMSTAT (number2)

     Description:

     This statement returns the status of a com port.  Number2 should contain
     "0" for COM1, or "1" for COM2.  The status of that COM port is returned in
     number1.  Each bit in number1 represents a different piece of information.
     These are described in the table below.  Note that you may test if a bit is
     on/off using the ZBIT command.

     Example:

          PORTSTAT = COMSTAT (0)
          DATAREADY = ZBIT(8,PORTSTAT)
          IF DATAREADY = 1 THEN GORECEIVE:

     These statements do the following.  The first retrieves the status of COM1
     to the variable PORTSTAT.  The second checks to see if bit 8 is on,
     DATAREADY will contain 1 if so, otherwise it will contain 0.  Since Bit 8
     is used to determine if data is waiting to be received from the port, if
     DATAREADY = 1 then the program will transfer to the label GORECEIVE: which
     would contain code to RECEIVE data from the port.

     Comments:

          Status Codes Returned by COMSTAT (Meaning when set to 1)

          Bit 0     Delta clear-to-send
              1     Delta data-set-ready
              2     Trailing-edge ring detector
              3     Delta receive line signal detect
              4     Clear-to-send
              5     Data-set-ready
              6     Ring Indicator
              7     Received line signal detect
              8     Data Ready
              9     Overrun error
             10     Parity error
             11     Framing error
             12     Break-detect error
             13     Transfer holding register empty
             14     Transfer shift-register empty
             15     Time-out error

     See also:

          OPENCOM,SEND,RECEIVE





                                      Page - 69


                                       CSRLIN

     Format:        number1 = CSRLIN

     Description:

     This function returns row of the cursor.

     Example:

                    LOCATE 10,20
                    A = CSRLIN

     The locate command will have positioned the cursor in row 10, column 20.
     After execution of the CSRLIN statement, "A" will contain the value of 10.

     See also:

          POS



































                                      Page - 70


                                        DATA

     Format:        DATA constant1[,constant2,...,constantn]

     Description:

     This statement is used store integer, decimal and string constants in
     memory for later retrieval by READ statements.  At least one constant must
     be specified, although multiples of each type are permitted.

     Example:

          DATA 1,"APPLE",2&,"ORANGES",1.2345

          READ A
          READ A$
          READ B&
          READ B$
          READ C@

     The above statements are equivalent of entering the following code:

          A=1
          A$="APPLE"
          B&=2&
          B$="ORANGES"
          C@=1.2345

     Comments:

     All DATA Statements must be placed at the beginning of the program, before
     all other statement types, except DIM or REM statements (or blank lines).
     DIM statements, if specified, must precede all other statements including
     DATA statements except REM statements (or blank lines).  As long as you
     follow these rules, you may specify an unlimited number of DATA statements.

     GWBASIC/BASICA does not require quotes around string constants in some
     instances.  ASIC always requires quotes around string constants.

     See also:

          READ,RESTORE












                                      Page - 71


                                        DATE$

     Format:        string1 = DATE$

     Description:

     This function returns the value of the system date in the format of "MM-DD-
     YYYY".

     Example:

          A$=DATE$
          PRINT A$

     After executing these statements, the date stored in the PC System Clock
     will be displayed on the screen.

     Comments:

     Note:  if the date printed is wrong, you have probably not set the system
     clock.  Most older XTs and PCs do not have a battery to preserve the DATE
     and TIME in the system clock, so you have to set them each time you power
     up the PC.  Most ATs and newer PCs have a battery backup, so that the date
     is preserved for you.

     Unlike GWBASIC/BASICA, you cannot set the system date with DATE$, however,
     you can set the system date from DOS by typing DATE.

     See also:

          TIME$, TIMER

                                       DEFSEG

     Format:        DEFSEG = number1

     This function is used to alter the default data segment used when peeking
     and poking data with PEEK and POKE statements.  DEFSEG, PEEK, and
     especially POKE are not recommended for beginners.  If number1 =-1, then
     the data segment address is set back to the ASIC default data segment
     address.

     Example:

          DEFSEG = -1

     Execution of the above statement would reset the default data segment to
     the default ASIC data segment.

     See also:

          PEEK, POKE, BLOAD, BSAVE


                                      Page - 72


                                         DIM

     Format:        DIM variable(integer1)

     Description:

     This statement will create one dimensional arrays.  An integer, decimal or
     string variable name must be specified in variable.  Integer1 contains the
     number of elements in the array.

     Example:

               DIM A(10)
               DIM A&(20)
               DIM A$(5)
               DIM A@(3)

     In this example an array of 10 normal integer variables is defined, an
     array of 20 long integer variables is defined, an array of 5 string
     variables is defined and an array of 3 decimal variables is defined.

     Comments:

     On the DIM statement, number1 may only be a constant.  Also, DIM statements
     must appear before all other statement types in the program except REM
     statements (or blank lines).


                                         END

     Format:        END [(number1)]

     Description:

     This statement causes your program to terminate and return to DOS,
     optionally setting a return code.  Number1 may be optionally specified to
     set the return code.  If omitted, ASIC uses a return code of zero by
     default.

     Example:
               END

     In this example, the program will terminate and return to DOS with a return
     code of zero.

               END (20)

     In this example, the program will terminate and return to DOS with a return
     code of "20".

     Comments:

     The optional return code is an extension over GWBASIC/BASICA.

                                      Page - 73


                                      ENVIRON$

     Format:        string1 = ENVIRON$(number1)

     Description:

     This statement will retrieve DOS environment strings.  Number1 identifies
     which string to retrieve.  If found, the string is placed in string1.  If
     not found, a NULL string (length=0) is stored in string1.

     Example:

          FOR I=1 TO 5
               A$=ENVIRON$(I)
               PRINT A$
          NEXT I

     The above example will retrieve the first five DOS environment strings and
     display them.

     Comments:

          If the requested DOS environment string entry is greater than 80
     characters in length, ASIC will truncate it at 80 characters.  Environment
     strings may be set in DOS using the SET command.  Environment strings are
     one way of passing information to your program.  Refer to your MS DOS
     Manual for more information.  Common uses of this command are to retrieve
     the user's PATH statement, or the COMSPEC variable.


                                         FILELEN

     Format:        number1 = FILELEN (string1)

     Description:

     This function will return the length in bytes of the specified file.
     String1 should contain a valid DOS file name.  The length of the file will
     be returned in Number1.  If the expected length of a file could exceed
     32767 bytes, declare number1 as a long integer or as a decimal variable.

     Example:

          LEN& = FILELEN("C:\AUTOEXEC.BAT")

     The above example will set variable LEN& to the length of
     "C:\AUTOEXEC.BAT".







                                      Page - 74


                                       FILEPOS

     Format:        number1 = FILEPOS (number2,number3)    <--Format 1
                    number1 = FILEPOS (number2,EOF)        <--Format 2
                    number1 = FILEPOS (number2,CURRENT)    <--Format 3

     Description:

     This statement is used to set or retrieve the read/write position for files
     opened in Random mode.  In all three formats, number2 is the file number of
     the file.  This file number must have been previously opened for Random
     mode by the OPEN statement.  Format 1 is used to set the current read/write
     position of the file specified by number2.  Number3 should be the offset
     (in bytes) from the start of the file.  Format 2 is used to set a
     read/write position of a random file to the end of the file.  Format 3 is
     used to retrieve the current read/write position (as a byte offset from the
     beginning of the file) of the file.  In all cases, if an error occurs, the
     system ERROR variable will be set.  A list of these codes is contained in
     the Error Codes Chapter of the ASIC Manual.  If no error occurs, then
     number1 will be set to the current read/write position of the file.

     Example 1:

          A&=FILEPOS(1, 100)

     This example assumes that file 1 was previously opened for RANDOM I/O using
     the OPEN statement.  After execution of this statement, the read/write
     position of file number 1 will be set to 100.  Subsequent PRINT #
     statements would write to the file starting at position 101.

     Example 2:

          A&=FILEPOS(1,EOF)

     This example assumes that file 1 was previously opened for RANDOM I/O using
     the OPEN statement.  After execution of this statement, the read/write
     position of file number 1 will be set to the end of the file.  Subsequent
     PRINT # operations to this file will result in data being appended to this
     file.

     Example 3:

          A&=FILEPOS(1,CURRENT)

     This example assumes that file 1 was previously opened for RANDOM I/O using
     the OPEN statement.  After execution of this statement, the current
     read/write position of file number 1 will retrieved and stored in A&.  The
     read/write position of file number 1 will NOT be altered after execution of
     this statement.

     Comments:



                                      Page - 75


     If you wish to use this command with files larger than 32767 bytes, you
     should use long integer or decimal numbers with this statement.  If you set
     the read/write position past the physical end of file and attempt to read
     from the file, you will receive an error on the INPUT# command.  If you set
     the read/write position past the end of file and issue a PRINT# command,
     the data will be correctly written at the position you specified.

     See also:

          OPEN, INPUT#, PRINT#, CLOSE, FILELEN












































                                      Page - 76


                                        FIND

     Format:        string1=FIND FIRST (string2,number1)
                    string1=FIND CONTINUE

     Description:

     The FIND command is used to search the current file directory for file(s)
     which match a search string.  This command has two versions.  FIND FIRST
     must be used to establish a new search and retrieve the first matching file
     name.  Thereafter, the FIND CONTINUE will retrieve additional file names
     which match the search string.  When performing the FIND FIRST, string2
     should contain the full or partial file name to be searched for.  This
     string can be up to 8 alphanumeric characters optionally followed by a
     period and up to 3 alphanumeric characters for the file extension.
     Standard DOS wild cards "*" and "?" may be included in the search string.
     Number1 is used to specify a file attribute.  If number1 is "0", then all
     normal files in the directory will be searched.  (A normal file is one in
     which the hidden, system, volume label, or directory attribute bit is NOT
     set).  Setting various bits (see table below) of number1 ON will expand the
     search to include normal files, plus those whose attributes have been
     specified in number1.  If a matching file name is found, then it will be
     stored in string1.  If an error occurs, then the system ERROR variable will
     be set.  A list of ERROR codes is contained in the ERROR code chapter of
     the ASIC Manual.  After the initial FIND FIRST has been performed, you may
     search for additional files which match the search string and attribute by
     issuing a FIND CONTINUE statement.

     Search Attributes bits (number1)
     --------------------------------

     BIT

     0    Not Used
     1    Hidden
     2    System
     3    Volume Label
     4    Subdirectory
     5-7  Not Used

     Note that these attributes can all be specified simultaneously.  For
     example, to specify both hidden and system, use an attribute value of
     &bin00000110 (in binary) or 6 (in decimal).

     Example:

               SEARCH$="*.ASI"
               ATTRIB=0
               FILENAME$=FIND FIRST (SEARCH$,ATTRIB)
               IF ERROR>0 THEN DONE:
               PRINT A$
          LOOP:FILENAME$=FIND CONTINUE
               IF ERROR>0 THEN DONE:

                                      Page - 77


               PRINT A$
               GOTO LOOP
          DONE: PRINT "ALL MATCHING FILES DISPLAYED"
          END

     After execution of the above statements, all of the files with a file
     extension of ".ASI" in the current directory will be displayed on the
     screen.

     Comments:

     If you execute a FIND CONTINUE without executing a FIND FIRST, then the
     results are unpredictable.  Additional information is retrieved by the FIND
     command besides the file name.  Advanced programmers can also find
     additional information using the PEEK command starting at offset 149 (from
     the default ASIC data segment).  Do not modify this data.  If you do so,
     the results are unpredictable.

     Additional File Information
     ---------------------------

     Address   Size (bytes)   Description


     149       1              File Attribute
     150       2              File Time Stamp
     152       2              File Date Stamp
     154       4              File Size (bytes)


     See also:

          NAME, KILL, GETDIR, CHDIR, MKDIR, RMDIR





















                                      Page - 78


                                      FOR/NEXT

     Format:        FOR number1 = number2 to number3
                    NEXT number1

     Description:

     These two statements are used to create a loop, so that you can execute a
     portion of your program a certain number of times.  All of the code between
     the FOR and the NEXT statement will be executed a certain number of times,
     but at least once.  The actual number of times the loop executes is
     dependent on number1/number2/number3. When the FOR statement is encountered
     in your program, number1 is assigned the value of number2.  Then the
     statements up to the matching NEXT statement is executed one time.  Then, 1
     is added to number1, and number1 is compared to number3.  If number1 is
     greater than number3 then the control passes to the statement following
     NEXT.  Otherwise, the program loops back up to the statement following the
     FOR statement.

     Example:

               FOR I = 1 TO 2
                    FOR J = 3 TO 5
                         PRINT I;
                         PRINT J
                    NEXT J
               NEXT I
               PRINT "AFTER THE LOOP";
               PRINT I;
               PRINT J;

     Execution of this section of code would result in the following printout:

               1    3
               1    4
               1    5
               2    3
               2    4
               2    5
               AFTER THE LOOP    3    6

     Comments:

     Unlike BASICA/GWBASIC, ASIC FOR/NEXT loops execute at least 1 time.  For
     example, the value "HELLO" will be printed in the following example.  It
     wouldn't have been in BASICA/GWBASIC.

               FOR I = 1 TO 0
                    PRINT "HELLO"
               NEXT I




                                      Page - 79


     Unlike GWBASIC/BASICA, arrays may be used for number1 and number2.
     However, if number3 is an array, element zero will be used, regardless of
     the subscript you specify.

     Loops which range from a negative to positive number are not supported (for
     performance reasons).  Such loops will terminate after 1 iteration.  For
     example, "FOR I =-10 to 10" will loop once.

     ASIC will allow you to modify the value of number3, while GWBASIC/BASICA
     ignores changes.

               J=1
               FOR I=1 TO J
                    J=2
               NEXT I

     The above loop will execute one time in GWBASIC/BASICA, but it will execute
     two times in ASIC.

     Also note:  The storage type of number3 must be the same as number1.  For
     example, if "number1" is a decimal variable, then "number3" must be a
     decimal variable--it may not be an integer variable.
































                                      Page - 80


                                       GETDIR

     Format:        string1=GETDIR (number1)

     Description:

     This statement is used to retrieve the current DOS directory.  Number1
     should be set to "0" to obtain the directory for the current drive, "1" for
     the "A" drive, "2" for the "B" drive, etc.  If the statement is
     unsuccessful, the system ERROR variable will be set.  A complete list of
     ERROR codes is contained in the Error Code Chapter of the ASIC Manual.  The
     directory string will be stored in string1.  The directory string will not
     contain the drive letter, or the first "\".  Thus, if the current directory
     on the specified drive was "C:\ASIC", then GETDIR would return "ASIC".  If
     the current directory was the root (e.g., "C:\"), then GETDIR would return
     a NULL string ("").

     Example:

          A$=GETDIR(0)

     After execution of this statement, the variable A$ will contain the name of
     current directory on the current disk drive.

     See also:

          FIND, MDKIR, RMDIR, CHDIR, GETDRIVE


                                      GETDRIVE

     Format:        string1 = GETDRIVE ()


     Description:

     This function will return the drive letter of the current DOS disk drive.

     Example:

          DRIVE$ = GETDRIVE()
          PRINT DRIVE$

     If the current disk drive was drive "C", the above sample code would cause
     "C:" to be printed on the screen.

     See Also:

          GETDIR





                                      Page - 81


                                       GETREGS

     Format:        GETREGS (AX,BX,CX,DX,DI,SI,BP,DS,ES)

     Description:

     This statement will retrieve the values of the CPU registers to ASIC
     variables with the same names.  For example, the CPU register AX is stored
     in an ASIC variable named AX.  If some of the registers are not needed, you
     can specify NA instead of the register name, in which case ASIC will
     generate slightly less code.

     Example:

          GETREGS (AX,BX,CX,DX,NA,NA,NA,NA,NA)

     The above example will retrieve the registers AX,BX,CX, and DX.  Registers
     DI, SI, BP, DS, and ES are not required, so NA is specified for them.

     See Also:

          SETREGS, INT86, CODE, PEEK, POKE


                                        GOSUB

     Format:        GOSUB label1

     Description:

     This statement "calls" a subroutine called "label1".  This subroutine must
     contain a "RETURN".  After the subroutine is executed, control is returned
     to the next statement following the GOSUB.

     Example:

               GOSUB PRINTIT:
               PRINT "All Done!"
               END
               PRINTIT:  PRINT "It"
               RETURN

     After execution of this code the screen would contain:

               It
               All Done!








                                      Page - 82


                                        GOTO

     Format:        GOTO label1

     Description:

          This statement transfers program execution to the statement identified
     by label1.

     Example:

               GOTO SKIPIT:
               PRINT "YOU'LL NEVER GET HERE"
               SKIPIT: PRINT "ALL DONE!"

     After execution of this code, the screen will appear as follows:

               ALL DONE!

     Note that the first print statement never executes because of the GOTO.


































                                      Page - 83


                                 IF/THEN/ELSE/ENDIF

     Format:        IF condition THEN label1                <--Format 1
                    IF condition THEN label1 ELSE label2    <--Format 2

                    IF condition THEN                         <--Format 3
                         <zero or more ASIC statements>
                    ENDIF

                    IF condition THEN                         <--Format 4
                         <zero or more ASIC statements>
                    ELSE
                         <zero or more ASIC statements>
                    ENDIF

     Description:

          This statement is used to conditionally transfer to a different
     location in the program.  The operand "condition" is one of the following:

          number1 > number2        number1 >= number2
          string1  > string2       string1  >= string2
          number1 = number2        number1 <> number2
          string1  = string2       string1  <> string2
          number1 < number2        number1 <= number2
          string1  < string2       string1  <= string2

     Format 1--If "condition" is true, control is transferred to label1.
     Otherwise the program continues at the next statement.

     Format 2--If "condition" is true, control is transferred to label1,
     otherwise the program branches to label2 and continues execution from
     there.

     Format 3--If "condition" is true, the program will continue execution at
     the next statement.  If the condition is false, the program will branch to
     the statement following the next ENDIF statement encountered.

     Format 4--If "condition" is true, program will continue execution at the
     next statement up to the next ELSE statement encountered, at which point it
     will branch to the statement following the next ENDIF statement
     encountered.  If "condition" is false, the program will branch to the next
     ELSE statement and resume execution at that statement.

     Example 1:

               IF A > 0 THEN APLUS:

     In this example, if A is greater than zero, the program jumps to the label
     called "APLUS:".

     Example 2:


                                      Page - 84


               IF A$="YES" THEN TRUE: ELSE FALSE:

     In this example, if A$ contains the string "YES", the program jumps to the
     label called "TRUE:", otherwise the program transfers to label "FALSE:"

     Example 3:

               OPEN "I",1,"TEST.DAT"
               IF ERROR>0 THEN
                    PRINT "ERROR OPENING FILE";
                    PRINT ERROR
                    END
               ENDIF
               REM rest of program follows
               .
               .

     In this example, if there is an error opening file "TEST.DAT", the program
     will print an error message and terminate.  Otherwise control will fall
     through to the REM statement and the program will continue.

     Example 4:

               PRINT "ENTER A NUMBER";
               INPUT NUMBER
               IF NUMBER > 100 THEN
                    PRINT "THAT'S A BIG NUMBER"
               ELSE
                    PRINT "THAT'S A SMALL NUMBER"
               ENDIF

     Comments:

     Formats 3 and 4 are BLOCK IF formats.  You can nest BLOCK IF statements up
     to 25 levels deep.  The example below is shown three levels deep.

          IF A=1 THEN                                  <-Level 1
               IF B=2 THEN                             <-Level 2
                    IF C=3 THEN                        <-Level 3
                         PRINT "C=3, B=2, AND A=1"
                    ELSE
                         PRINT "C<>3, B=2, AND A=1"    <-ELSE  for Level 3
                    ENDIF                              <-ENDIF for Level 3
               ENDIF                                   <-ENDIF for Level 2
          ENDIF                                        <-ENDIF for Level 1

     It's a good idea to indent your IFs, ELSEs and ENDIFs as shown above.
     Otherwise matching IFs up with matching ENDIFs and ELSEs can become very
     confusing.





                                      Page - 85


                                       INKEY$

     Format:        string1 = INKEY$

     Description:

     Used to retrieve keystrokes from the keyboard buffer.  If a character is
     waiting in the buffer, string1 will be set to the value of that character,
     and that character will be removed from the keyboard buffer.  If the buffer
     is empty, string1 will be set to a value of "" (that is, a null string with
     a length of 0).  If an extended key is pressed (for example the function
     keys F1 through F10), the system variable EXTENDED will be set to 1,
     otherwise it will contain 0.

     Example:

               LOOP: X$=INKEY$
               IF X$="" THEN LOOP:

     The above code will cause the program to loop until a key is pressed.

     Comment:

     ASIC provides an extension here over BASICA/GWBASIC.  The EXTENDED system
     variable will allow you to detect special keys as mentioned above.  To do
     so requires an understanding of keyboard scan codes, which is beyond the
     scope of the ASIC Manual.  For more information I would suggest Peter
     Norton's Programmer Guide to the IBM PC (Microsoft Press).


                                         INP

     Format:        number1 = INP (number2)

     Description:

     This statement reads a byte from port number2 and stores the result in
     number1.

     Example:

          A=INP(513)
          A=ZBIT(4,A)
          IF A=1 THEN TRIGGERPRESSED:

     The above code will test the joystick port to see if the trigger is being
     pressed on joystick 1.  You need a game card and joystick for this to work.

     See also:

          OUT



                                      Page - 86


                                        INPUT

     Format:        INPUT variable1     <--Format 1
                    INPUT variable1;    <--Format 2

     Description:

     This statement will retrieve a line of text from the input buffer and store
     it in variable1.  There are two statement formats.

     When using Format 1, ASIC will first issue the prompt "?".  It will then
     wait until the user enters a string or number and presses the <enter> or
     <enter> key.  The type of data ASIC will expect is dependent on the type of
     variable1 (integer, decimal, or string).  If an integer or decimal is being
     entered, ASIC will edit the input for validity. If the edit fails ASIC will
     issue another "?" to the user, and will wait for the number to be retyped.
     Only when a valid integer has been entered will variable1 be updated, and
     only then will control return to your ASIC program.  Following a successful
     INPUT, ASIC will generate a carriage return/line feed sequence and advance
     the cursor to the next line.

     When using Format 2, ASIC will NOT issue a prompt.  It will still edit the
     user input based on the type of variable.  However, if the input is invalid
     it does not reprompt the user to re-enter the data.  Instead, it will set
     the system ERROR variable to "1" and return control to your ASIC program.
     The value stored in variable1 will be undefined if the ERROR variable is
     set!  ASIC will issue a carriage return, but it will NOT issue a line feed.
     Format 2 is useful when you want to use the INPUT statement with it's data
     edit capabilities in conjunction with a data entry form.  In this case, you
     don't want ASIC to write any prompts to the screen, and you don't want ASIC
     to scroll the screen.

     Example 1:

               PRINT "Enter a String";
               INPUT A$

     ASIC will issue the prompt:

               Enter a String?

     It will then wait until you enter a string or press enter.  If you pressed
     enter with no characters A$ would contain "" (i.e. its length would equal
     0), otherwise A$ would contain the string entered.

     Example 2:

               INPUT I

     In this example ASIC will issue the prompt:

               ?


                                      Page - 87


     ASIC will then wait for you to enter a valid number.  If you enter an
     invalid number, say "x", ASIC will reissue the "?" prompt and wait for you
     to retype your input.  Once the input has been edited by ASIC, "I" would
     contain the number entered.

     Example 3:

          LOOP:
               PRINT "YOUR CHOICE?";
               INPUT A;
               IF ERROR=1 THEN
                    PRINT "THE NUMBER YOU ENTERED WAS INVALID"
               END IF
               GOTO LOOP:

     This example uses Format 2.  Notice that since ASIC will not issue a
     prompt, we must include the "?" on the PRINT statement or it will not
     appear on the screen.  Also note that errors fall through.  If an error is
     detected the message "THE NUMBER YOU ENTERED WAS INVALID" will be
     displayed, and the program will branch to the label "LOOP:" to ask for the
     input again.

     See Also:

          INKEY$





























                                      Page - 88


                                       INPUT#

     Format:        INPUT# number1, number1                 <-Format 1
                    INPUT# number1, string1                 <-Format 2
                    INPUT# number1, string1 CRLF            <-Format 3
                    INPUT# number1, string1 NONULL          <-Format 4
                    INPUT# number1, string1 BYTE            <-Format 5

     Description:

     This statement will read a variable from a file identified by file number
     number1.  It will be stored in number1/string1.  If an error occurs during
     a read, the system variable ERROR will be set to a non-zero value.  The
     possible errors are listed in the error messages section the of the ASIC
     Manual.  If you read a file past its end, the contents of variable1 are
     undefined.

     Five formats of this statement are provided to provide greater flexibility
     in reading files written by ASIC and non-ASIC programs.  The five formats
     are summarized below:

     Format 1 -- Read numeric data from a file previously written by ASIC.

     Format 2 -- Read string data from a file previously written by ASIC.

     Format 3 -- Read strings from a non-ASIC file.  Assumes the strings
     (CRLF)      will be terminated by a CR/LF (carriage return/linefeed).
                 Note that ASIC still considers a NULL character, if
                 encountered, as an end of string character.  Also ASIC
                 terminates the string if 80 characters are read before
                 encountering a CR/LF pair.

     Format 4 -- Read strings from a file until 80 characters or the end
     (NONULL)    of the file is reached.  Note that ASIC still considers a
                 NULL character, if encountered, as an end of string
                 character.

     Format 5 -- Reads a single byte from a file and stores it in string1.
     (BYTE)      If ASIC has read a NULL byte, the string will be set to
                 NULL and its length will be 0.

     Example 1:

          OPEN "I",1,"TEMP.DAT"
          INPUT#1, A$
          IF ERROR=99 THEN ENDOFFILE:

     In this example, a string will be read from file "TEMP.DAT", and it will be
     stored in A$.  The system ERROR variable is then checked to see if End of
     file was reached.  Note, other ERRORS could also be returned by INPUT#,
     besides error code 99.  Refer to the error messages section for more
     information.


                                      Page - 89


     Example 2:

          OPEN "I",1,"TEMP.DAT"
          INPUT#1, A$ NONULL
          IF ERROR=99 THEN ENDOFFILE:

     In this example, ASIC will read 80 characters from the file "TEMP.DAT", or
     up until the next NULL character in the file, which ever comes first.

     Example 3:

          OPEN "I",1,"CONFIG.DAT"
          INPUT#1, A$ BYTE
          IF ERROR=99 THEN ENDOFFILE:

     In this example, ASIC will read a single character from the file
     "CONFIG.DAT", and place it in the variable A$.

     Example 4:

          OPEN "I",1,"TEST.DAT"
          INPUT#1, A
          IF ERROR=99 THEN ENDOFFILE:

     In this example, ASIC will read an integer value from the file "TEST.DAT",
     and place it in the integer variable "A".

     Example 5:

          OPEN "I",1,"ASCII.DAT"
          OPEN "O",2,"ASCII.NEW"
          CR$=CHR$(13)
          LF$=CHR$(10)
          CRLF$=CR$+LF$
     READMORE:
          INPUT #1, A$ CRLF
          IF ERROR=96 THEN WRITE:
          IF ERROR>0 THEN ENDOFFILE:
     WRITEWITHCRLF:
          PRINT #2,A$ NONULL
          PRINT #2,CRLF$ NONULL
          GOTO READMORE:
     WRITE:
          PRINT #2, A$ NONULL
          GOTO READMORE:
     ENDOFFILE:
          CLOSE 1
          CLOSE 2

     This example copies file ASCII.DAT to file ASCII.NEW.  Note:  Even though
     ASIC can only handle 80 character strings, this example shows that by
     checking the ERROR variable for a value of 96, it is possible to read the
     file in up-to-80-character chunks and reassemble the strings in their

                                      Page - 90


     original forms in the new file.  Also note that ASIC will still treat any
     NULL characters in the file as an end of string character.

     Comments:

     Note that number1 must be a constant in the range of 1-3.  It identifies a
     file by file number which must have previously been opened by an OPEN
     command for modes INPUT or RANDOM.

     ASIC assumes that integers will be stored in files in 2-byte binary format,
     which is the format ASIC writes integers.  Consequently, If a file
     contained a string "123", but you told ASIC to read integer "X", then ASIC
     would read two bytes from the file and interpret "12" as two binary bytes
     that it would then combine and store as "X".  "X" would contain the integer
     value 12849.  Thus to read an integer correctly, you will have had to
     previously written it with an ASIC program.

     See Also:

          OPEN, CLOSE, PRINT#, FILEPOS


































                                      Page - 91


                                        INSTR

     Format:        number1 = INSTR (string1,string2)

     Description:

     This statement is used to determine if a given substring exists within a
     string, and if so, the character position at which the substring first
     appears in the string.  String1 is the string to be searched.  String2
     contains the substring to find within string1.  The character position of
     string2 within string1 is returned in number1.  If the string is not found
     then number1 is set to zero.

     Example 1:

          A=INSTR("THE QUICK BROWN FOX","QUICK")

     After execution of this statement, variable "A" will contain the value 5,
     which is the offset of the string "QUICK" within the string "THE QUICK
     BROWN FOX".

          B=INSTR("FOX","HEN")

     After the execution of this statement, variable "B" will contain 0, since
     the string "HEN" is not found within the string "FOX".

     See also:

          LEFT$, RIGHT$, MID$, LEN

























                                      Page - 92


                                        INT86

     Format:        INT86(number1,AX,BX,CX,DX,DI,SI,BP,DS,ES)

     Description:

     This statement is used to call a DOS, BIOS, or custom-written Interrupt.
     Number1 must be a constant, and should identify the number of the interrupt
     to be called.  The fields following number1 represent the CPU registers.
     For example, ASIC will move the value from the ASIC variable "AX" to the
     CPU register "AX" prior to performing the interrupt call.  After the call,
     ASIC will move the value from the CPU register "AX" to the ASIC variable
     "AX".  Your ASIC program can then use this "AX" variable just like any
     other integer variable in the rest of the program.  Each of the registers
     listed (AX,BX,CX,DX,DI,SI,BP,DS,ES) must be included on the INT86 statement
     in the same order as shown in the Format statement above.  The exception to
     this rule, is that you can substitute "NA" for any register you do not need
     for the call.  The BP register may be used to pass values to the INT86
     call, however, unlike all of the other registers, ASIC does not return the
     value of the BP register following the INT86 call.

     Example 1:

               INT86(5,NA,NA,NA,NA,NA,NA,NA,NA,NA)

     The above example shows the code to perform a screen print to the printer.
     This example will call INT 5 (BIOS Print Screen Interrupt), pass no
     parameters to the call, and receive no return values from the call.

     Example 2:

               AX=&hex3600
               DX=0
               INT86(&hex21,AX,BX,CX,DX,NA,NA,NA,NA,NA)
               PRINT "Default Drive has:"
               PRINT
               PRINT "Sectors/Cluster";
               PRINT AX
               PRINT "Available Cluster Count";
               PRINT BX
               PRINT "Bytes/Sector";
               PRINT CX
               PRINT "Total Clusters";
               PRINT DX

     This example show a more complex call to DOS to find out free disk space
     information for the current drive.  DOS Interrupt 21 (hex) function 36
     (hex) is used to retrieve this information.  The AX register is used to
     pass the function number.  The DX register is used to select the disk drive
     (0=the default disk drive).  Note that the BX and CX registers were
     included on the call.  No parameters are being passed to the call in these
     registers, however, we'll be receiving information back from DOS in them,
     so they need to be on the INT86 statement.  Since the SI,DI,BP,DS, and ES

                                      Page - 93


     registers are not needed by the call, they have been substituted with "NA"
     which you can think of as meaning "Not Applicable" to this call.  After the
     call, the example program will display information about the default disk
     drive.

     Comments:

     This statement is intended for advanced programmers.  To use it properly,
     you must have some knowledge of assembler language, or (at least) the CPU
     registers in the IBM PC.  You also need a DOS or BIOS reference manual to
     identify which registers to pass to each interrupt, and to identify the
     values to place in those registers.

     One register was required for ASIC housekeeping after the INT86 call.  This
     is why the BP register is unavailable to receive return values from calls.
     The BP register was chosen, because none of the DOS or BIOS Interrupts use
     this register to return values.  If you write your own interrupts and want
     to call them from an ASIC program, remember that you can pass the BP
     register to the interrupt, but the ASIC "BP" variable will not be updated
     following the interrupt.

     If a register is not needed for the call, specify "NA" instead of the
     register name.  ASIC does not generate any code for "NA" registers, and
     this will reduce the size of your program.

     See also:

          CODE, GETREGS, SETREGS, PEEK, POKE


























                                      Page - 94


                                        KILL

     Format:        KILL string1

     Description:

     This statement is used to delete a file from disk.  It is similar to the
     DOS ERASE Statement.  Specify the file to delete in string1.  You can
     specify the full path to the file, or just the file name if it is in the
     current directory.  If an error occurs (e.g., File not found), then ASIC
     will set the System ERROR variable.  A list of codes returned by KILL is
     listed in the ERROR Messages Chapter of the ASIC Manual.

     Example:

               KILL "TEMP.DAT"
               IF ERROR = 0 THEN NOERROR:
               REM CHECK ERROR CODES HERE

     After this statement is executed, the file "TEMP.DAT" will have been erased
     from the current directory of the current drive, and will no longer be
     accessible from DOS or your programs.

                                       LCASE$

     Format:        string1=LCASE$(string2)

     Description:

     This statement will convert all of the letters in string2 from upper case
     to lower case, and store the result in string1.

     Example:

          A$=LCASE$("123 Main Street, USA")

     After the execution of this statement, the variable A$ will contain the
     string "123 main street, usa".

     See also:

          UCASE$












                                      Page - 95


                                        LEFT$

     Format:        string1=LEFT$(string2,number1)

     Description:

     This statement will copy number1 characters from the left of string2 to
     string1.

     Example:

          A$=LEFT$("RED RIDING HOOD",3)

     After the execution of the above statement, the variable A$ will contain
     the string "RED".

     See also:

          MID$, RIGHT$


                                         LEN

     Format:        number1 = LEN (string1)

     Description:

     This statement returns the length (number of characters) of a string, and
     stores the length in number1.

     Example:

               A$="abc"
               LENGTH1 = LEN(A$)

     After execution of these statements, LENGTH1 would contain 3.


















                                      Page - 96


                                       LOCATE

     Format:        LOCATE row,column

     Description:

     This statement is used to position the cursor to a row and column.  Row and
     Column should be integers.  Row has the range 0-24, Column has the range 0-
     79.  This function does not perform edits on the ranges of row and column.
     Consequently using this function with values outside these ranges will have
     unpredictable results.

     Example:

               LOCATE 10,20
               PRINT "HELLO"


     After execution of these statements, the message "HELLO" will appear
     beginning at row 10, column 20.


                                       LPRINT

     Format:        LPRINT printobject [;]

     Description:

     This statement is used to send the contents of printobject to an attached
     printer.  "printobject" can be any valid ASIC datatype:  integer, string,
     or decimal number.  Optionally, a ";" can be included with this statement
     to suppress a carriage return/line feed which ASIC normally also sends to
     the printer following each LPRINT.  This can be used to string several
     printobjects together on a single print line.

     Example:

               A=12345
               LPRINT "The value of A is: ";
               LPRINT A

     After execution of these statements the printer would print:

               The value of A is: 12345

     Comments:

     Note that if the printer is not "online" that DOS will issue a message to
     "Abort, Retry, or Ignore".  This could overwrite a portion of the program
     display, unless not planned for.

     Note also, that some printers do not begin printing until they receive a
     carriage return/line feed sequence.

                                      Page - 97


                                       LTRIM$

     Format:        string1=LTRIM$(string2)

     Description:

     This statement will remove all leading spaces from string2 and store the
     result in string1.

     Example:

          A$="   XYZ"
          A$=LTRIM$(A$)

     After execution of these statements, the variable A$ will contain the
     string "XYZ" with no leading spaces.

     See also:

          RTRIM$


                                        MID$

     Format:        string1 = MID$(string2,number1,number2)

     Description:

     This statement is used to extract a substring from string2 beginning at
     position number1 within string2 and continuing for number2 bytes.  This
     value is then stored in string1.

     Example:

                    A$="THE QUICK BROWN FOX"
                    B$=MID$(A$,1,4)
                    C$=MID$(A$,11,9)
                    D$=B$ + C$

     After execution of these statements, the contents of A$ will be unchanged.
     The contents of B$ will be "THE ".  The contents of C$ will be "BROWN FOX",
     and the contents of D$ will be "THE BROWN FOX".

     See also:

          LEFT$, RIGHT$








                                      Page - 98


                                        MKDIR

     Format:        MKDIR string1

     Description:

     This statement is used to create a new DOS directory.  Specify the
     directory to create in string1.  If ASIC is unable to create the directory,
     it will set the System ERROR variable.  A list of ERROR codes may be found
     is the Error Messages Chapter of the ASIC Manual.

     Example:

               MKDIR "WORK"
               IF ERROR = 0 THEN NOERROR:

     This code would create a directory called "WORK" under the current
     directory of the current drive.

     Example 2:

               MKDIR "C:\WORK"

     This code would create a directory called "WORK" under the root directory
     of drive "C".

     See also:

          CHDIR,RMDIR


                                         MOD

     Format:        integer1 = number2 MOD number3

     Description:

     This statement will perform modulo division of number2 by number3 and store
     the remainder (instead of the quotient) in integer1.

     Example:

               A = 8
               B = 5
               C = A MOD B

     After execution of these statements, variable "C" will contain the value
     "3" which is the remainder of the division of 8 by 5.






                                      Page - 99


                                        NAME

     Format:        NAME string1 AS string2

     Description:

     This statement will allow you to rename a file.  String1 should contain the
     current file name, and string2 should contain the new name for the file.
     If ASIC is unable to rename the file, it will set the System ERROR
     variable.  A list of ERROR codes is contained in the Error Messages Chapter
     of the ASIC Manual.

     Example:

          NAME "olddata.txt" AS "newdata.txt"
          IF ERROR = 0 THEN SUCCESS:

     After execution of these statements, file "olddata.txt" will have been
     renamed to "newdata.txt"

     Comments:

          You cannot rename a file to a new disk drive.































                                     Page - 100


                                        OPEN

     Format:        OPEN string1, number1, string2

     Description:

     This statement is used to open a file for input or output.  Up to three
     files may be open concurrently, these are known as file 1, 2, or 3.  You
     must specify with number1 which file number you wish to open this file as.
     Number1 may only be a constant.  The file mode is specified in string1.
     The valid values are "I" for INPUT, "O" for OUTPUT, "A" for APPEND, and "R"
     for RANDOM INPUT/OUTPUT.  The file name is specified with string2.  Any
     errors returned from DOS on the OPEN call will be returned in the system
     variable "ERROR".

     Example:

               OPEN "I",3,"INFILE"
               IF ERROR > 0 THEN PROCESSERROR:
               OPEN "O",1,"A:\NEWFILE.DAT"
               IF ERROR > 0 THEN PROCESSERROR:

     In this example, two files are opened.  File "INFILE" from the current disk
     drive and directory will be opened as file number 3 for input.  The file
     "A:\NEWFILE.DAT" will be opened for output as file number 1.  Note that if
     "A:\NEWFILE.DAT" previously existed, it contents will be destroyed in
     preparation for writing.

     See also:

          LOSE, FILEPOS, INPUT#, PRINT#























                                     Page - 101


                                       OPENCOM

     Format:        OPENCOM(number1,number2,number3,number4,number5)

     Description:

     This statement is used to initialize the serial port.  Number1 is used to
     specify the baud rate.  Number2 specifies parity.  Number3 specifies stop
     bits.  Number4 specifies bytesize, and Number5 identifies which port to
     open (see the tables below).  OPENCOM does not check the validity of the
     values you give it.

               (number1)                (number2)
               BAUD RATE                PARITY
          ------+-----------       ------+------------
          VALUE | DESCRIPTION      VALUE | DESCRIPTION
            0   | 110  baud          0   | No Parity
            1   | 150  baud          1   | Odd Parity
            2   | 300  baud          3   | Even Parity
            3   | 600  baud
            4   | 1200 baud            (number3)
            5   | 2400 baud            STOP BITS
            6   | 4800 baud        ------+------------
            7   | 9600 baud        VALUE | DESCRIPTION
                                     0   | One Stop Bit
                                     1   | Two Stop Bits

               (number4)                (number5)
               BYTE SIZE                COM PORT
          ------+------------      ------+------------
          VALUE | DESCRIPTION      VALUE | DESCRIPTION
            2   | 7 Bits             0   | Com1
            3   | 8 Bits             1   | Com2

     Example:

               OPENCOM(2,0,0,3,0)

     This statement would open COM1 at 300 baud, No parity, 1 Stop bit, 8 bit
     bytesize.

     See also:

          COMSTAT,RECEIVE,SEND










                                     Page - 102


                                         OUT

     Format:        OUT (number1,number2)

     Description:

     This statement writes a byte to a port.  Number1 should contain the port to
     write to.  Number2 should contain an integer value in the range of 0-255 to
     be written to the port.

     Example:

          OUT 512,0

     The above statement would send a byte with the binary value of "0" to port
     number 512.

     See also:

          INP


                                        PEEK

     Format:        number1 = PEEK (number2)

     Description:

     This statement is used to examine actual memory location values directly.
     By default, the ASIC DS address is assumed.  However, this may be
     overridden with the use of the DEFSEG command.  The value of the byte at
     address number2 is stored in number1.

     Example:

          DEFSEG = &hexB800
          A = PEEK (0)

     The above statements will retrieve the first byte of video memory for a
     CGA/EGA/VGA card and store it in variable "A".

     Comments:

     Since the Intel 8088 architecture is segmented in 64k segments, number2 is
     limited to the range of 0-65535.

     See also:

          DEFSEG, POKE





                                     Page - 103


                                        POINT

     Format:        number1 = POINT (number2,number3)

     Description:

     This statement is used to determine the color of a given pixel in medium
     and high resolution graphics modes.  The row to test is specified with
     number2, the column with number3.  The color of the pixel is stored in
     number1.

     Example:

               PCOLOR = POINT (10,20)

     After execution of this statement, PCOLOR will contain the color of the
     pixel in row 10 column 20.

     Comments:

     No range checking is performed on row and column.  If the specified row or
     column is outside the valid range for the given graphics mode, the results
     are unpredictable.

     See also:

          PSET, PRESET, SCREEN



























                                     Page - 104


                                        POKE

     Format:        POKE number1, number2

     Description:

     This instruction is used store the byte value number2 at the memory address
     specified by number1.  By default, ASIC uses its default data segment
     address, however, this may be overridden with the DEFSEG statement.

     Example:

          DEFSEG = &hexB800
          POKE 0,1

     The above statements will store a byte with the binary value of "1" in the
     first byte of video memory for a CGA/EGA/VGA card.

     Comments:

     This statement is NOT RECOMMENDED FOR BEGINNERS.  Directly overwriting
     memory locations can be disastrous, unless you know what is stored at that
     address.  This can cause program "hangs", system crashes, etc.

     Since the Intel 8088 architecture is segmented in 64k segments, number2 is
     limited to the range of 0-65535.


     See also:

          DEFSEG, PEEK























                                     Page - 105


                                         POS

     Format:        number1 = POS (number2)

     Description:

     This statement finds the column number of the cursor and stores it in
     number1.  number2 is a dummy argument included only because a dummy
     argument is required in BASICA/GWBASIC.

     Example:

          A = POS(0)

     After this statement executes, A will contain the column number of the
     cursor.

     See also:

          CSRLIN


                                       PRESET

     Format:        PRESET (number1,number2)

     Description:

     This statement is used to set the color of a pixel to the background color.
     The row of the pixel is specified in number1, and the column is specified
     in number2.  This statement only works in graphics modes.

     Example:

          PRESET (10,20)

     The pixel at row 10 column 20 would be set to the background color.

     See also:

          PSET, SCREEN, POINT













                                     Page - 106


                                        PRINT

     Format:        PRINT [printobject1 [;]]

     Description:

     This statement is used to print to the screen.  Printing begins at the
     current cursor location.  Printobject1 is defined as any valid ASIC data
     type:  integer constant, integer variable, decimal constant, decimal
     variable, string constant, string variable, and arrays.  The semicolon is
     optional and is used to tell ASIC if you want a carriage return/line feed
     issued.  A semicolon at the end of a PRINT statement will suppress the
     carriage return/line feed ASIC normally issues.  If no operands are
     supplied, ASIC will simply issue a carriage return and line feed.

     Example 1:

               A=1000
               PRINT "A=";
               PRINT A
               PRINT
               PRINT "DONE!"

     After execution of these statements your screen would display:

               A=  1000

               DONE!

     See also:

          COLOR, SCREEN, LOCATE






















                                     Page - 107


                                       PRINT#

     Format:        PRINT# constant1, printobject1 [NONULL]

     Description:

     This statement is used to write integers, decimals and strings to disk.
     Constant1 identifies the file number that the file was opened as.  This
     must be a constant with a value of 1, 2 or 3.  The file must have been
     previously opened with the OPEN command.  If printobject1 is a string, you
     can also add the optional argument "NONULL", which will cause ASIC to
     suppress the trailing NULL character it would normally write to disk.  DOS
     errors are returned in the system variable "ERROR".  A list of these error
     codes may be found in the error messages section of the ASIC Manual.  Also,
     refer to the technical details section of the ASIC Manual for more
     information on the format in which ASIC writes the data to disk.

     Example:

               PRINT# 1, "HELLO"
               IF ERROR = 255 THEN DISKFULL:
               PRINT# 1, "WORLD"
               IF ERROR = 255 THEN DISKFULL:

     After successful execution of the print statements the file identified by
     file number 1 would contain "HELLO0WORLD0" . Note that the "0" following
     HELLO and WORLD in our example represents the ASCII null character.
     Strings in ASIC are always internally terminated with ASCII null
     characters.  By default, these nulls are also written to disk.

               PRINT# 2, "HELLO" NONULL

     In this example, the string "HELLO" would be written to file #2, and no
     trailing NULL will be written to disk.

               PRINT #3, 1234

     In this example, the number "1234" would be written to file #3 as two bytes
     in Intel binary format (the file would contain the two hexadecimal bytes:
     D2 04).

     Comments:

       Note that while ASIC doesn't generate carriage returns and line feeds for
     you as it does with the PRINT command, you can write these characters to
     disk as follows:

               A$=CHR$(13)
               B$=CHR$(10)
               A$ = A$ + B$
               PRINT #1, A$



                                     Page - 108


     You might be wondering about the purpose of the NONULL option.  ASIC
     normally writes trailing NULLs with strings.  This is desirable if you plan
     to read the file exclusively with other ASIC programs.

     However, sometimes you may want to write a string for use by another
     program.  In this case, the NULL character sometimes confuses the other
     program.  Specifying the NONULL option will cause ASIC to suppress the
     offending NULL character.

     What happens if you read a string that is terminated by a Carriage
     Return/Line Feed Sequence (such as GWBASIC/BASICA produces)?  In this
     instance, specify the CRLF option on the INPUT# statement.  Then ASIC will
     read the string until it finds a CR/LF or until it reads 80 characters,
     whichever comes first.

     See also:

               OPEN, CLOSE, INPUT#, FILEPOS




































                                     Page - 109


                                        PSET

     Format:        PSET (number1,number2),number3

     Description:

     This statement is used to set a pixel to a specified color in graphics
     modes.  The row is specified in number1, the column in number2, and the
     color in number3.  Note that no range checking is performed on number1 or
     number2.  A row or column specified outside the range allowed by the
     graphics mode in use can result in unpredictable results.

     Example:

               PSET (10,20),1

     In this example the pixel defined at row 10 and column 20 will be set to
     color 1.

     See also:

          PRESET, SCREEN, POINT


                                      RANDOMIZE

     Format:        RANDOMIZE

     Description:

     This statement will cause the seed for the random number generator to be
     reseeded using the system timer.  This statement should always precede the
     first RND statement in your program, unless you want the same sequence of
     random numbers generated.

     Example:

          RANDOMIZE

     The above statement would insure that each time your program runs, any
     subsequent RND numbers generated would be different.

     See also:

          RND









                                     Page - 110


                                        READ

     Format:        READ variable1

     Description:

     This statement reads a constant from DATA statements into a variable.
     Variable1 is a string, decimal or integer type variable.

     Example:

          DATA 7,"CARGO"

          READ A
          READ B$

     After execution of these statements, "A" will contain 7, and B$ will
     contain "CARGO".

     Comments:

     ASIC does not check to see that the data type on the READ statement matches
     the data type on the DATA statement.  It is up to the programmer to insure
     that the types match.  The above example is correct.  The DATA statement
     contains an integer, then a string.  This is the same sequence in which the
     DATA is READ (i.e., integer, then string).  In the above example, if the
     read statements were reversed, the contents of A and B$ are undefined.
     Also note that ASIC does not check to see that you don't read past the end
     of the DATA you specified.  In the above example, if you had a third READ
     statement that contained "READ C$", then C$ would contain random garbage,
     since you read three values, but only provided data for two.

     See also:

          DATA,RESTORE



















                                     Page - 111


                                       RECEIVE

     Format:        variable1 = RECEIVE(number2)

     Description:

     This statement will read a byte from the specified serial port.  Number2
     identifies which port to read (0=COM1, and 1=COM2).  The byte read is
     stored in variable1 (which may be an integer or string type variable).
     Before executing this statement you should first check to see if there is
     data waiting to be read.  Executing this statement when data is not waiting
     can cause your PC to "hang" until data is received at the hardware serial
     port.  The example below illustrates how to determine if data is waiting to
     be received.

     Example:

          OPENCOM(2,0,0,3,0)

          PORTSTAT = COMSTAT(0)
          DATAREADY = ZBIT(8,PORTSTAT)
          IF DATAREADY = 0 THEN NODATAWAITING:
          A$=RECEIVE(0)

     These statements do the following.  The first retrieves the status of COM1
     to the variable PORTSTAT.  The second checks to see if bit 8 is on,
     DATAREADY will contain 1 if so, otherwise it will contain 0.  Since Bit 8
     is used to determine if data is waiting to be received from the port, if
     DATAREADY NOT = 0 then the program will RECEIVE data from the port to
     variable "A$".

     Comments:

     Variable1 can be either a string or integer type variable.  However, if
     variable1 is a string, bear in mind that you cannot directly receive a NULL
     (ASCII Code 0), since NULL is used to delimit the end of a string in ASIC.
     However, if in the above example data was waiting at the port but A$
     contained "" after the receive, you would know that the character received
     was a NULL.  This is not a problem if variable1 is an integer variable.

     See also:

          OPENCOM,SEND,COMSTAT











                                     Page - 112


                                         REM

     Format:        REM  free form comments

     Description:

     This statement is used to insert comments into your program.  Everything
     following REM is treated by ASIC as a comment.

     Example:

          REM The compiler will ignore this line


                                       RESTORE

     Format:        RESTORE

     Description:

     This statement allows you to READ data from DATA statements after you have
     already READ it once.

     Example:
               DATA 0

               READ A
               RESTORE
               READ B

     In this example, "READ A" causes variable "A" to be set to 0.  Now, the
     DATA statement is "used up".  There is no more data left on it to be read.
     The RESTORE resets the DATA so that the next statement "READ B" will result
     in "B" being set to 0.  If the RESTORE was not done, the contents of B
     would be undefined.

     See also:

          READ, DATA















                                     Page - 113


                                       RETURN

     Format:        RETURN

     Description:

     Used to return from a GOSUB call.

     Example:

          GOSUB PRINTIT:
          END

          PRINTIT: PRINT "IT"
          RETURN

     In the above example, the word "IT" will be printed on the screen.  The
     RETURN statement causes program execution to resume on the statement
     following the corresponding GOSUB statement.  In this example, control will
     be returned to the END statement.

     Comments:

     Executing a RETURN statement without having first executed a GOSUB
     statement could cause unpredictable results.

     See also:

          GOSUB


                                       RIGHT$

     Format:        string1 = RIGHT$(string2,number1)

     Description:

     This statement will copy the rightmost number1 characters from string2 to
     string1.

     Example:

          A$=RIGHT$("RED RIDING HOOD",4)

     After the execution of the above statement, the variable A$ will contain
     the string "HOOD".

     See also:

          MID$, LEFT$




                                     Page - 114


                                        RMDIR

     Format:        RMDIR string1

     Description:

     This statement will delete an empty directory from disk.  String1 should
     contain the name of the directory to delete.  If ASIC is unable to delete
     the directory, it will set the System ERROR variable.  A list of ERROR
     codes is listed in the Error Messages Chapter of the ASIC Manual.

     Example:

               RMDIR "C:\WORK\TEST"
               IF ERROR = 0 THEN SUCCESS:

     After execution of this code, the directory TEST under directory WORK will
     be deleted (if it had no files or subdirectories in it, and if it is not
     the current directory for drive "C").

     See also:

          MKDIR,CHDIR































                                     Page - 115


                                         RND

     Format:        number1 = RND (number2)

     Description:

     This statement will return an integer number in the range of 0 through
     32767 for normal integers, and in the range of 0 to 2,147,483,647 for long
     integers. This random number will be stored in number1.  Number2 is a dummy
     argument and can be any valid integer value.  If number1 is a decimal
     variable, the random number returned will be an integer in the range of 0
     to 2,147,483,647.

     Example 1:

               A& = RND(0)

     After execution of this statement "A" will contain a number between 0 and
     2,147,483,647 inclusive.

     Example 2:

               RANDOMIZE

               DIEROLL=RND(0)
               DIEROLL=DIEROLL MOD 6
               DIEROLL=DIEROLL+1
               PRINT "YOU ROLLED A";DIEROLL

     The above example demonstrates how to generate a number in a given range.
     In this case, the range will be 1-6, which would be suitable for simulating
     the roll of a die.  The above example will generate the simulated die roll,
     and print the result.

     Comments:

              In BASICA/GWBASIC, RND always returns a value between 1 and 0.

















                                     Page - 116


                                       RTRIM$

     Format:        string1=RTRIM$(string2)

     Description:

     This statement will remove all trailing spaces from string2 and store the
     resulting string in string1.

     Example:

          A$=RTRIM$("XYZ   ")

     After the execution of this statement, the variable "A$" will contain
     "XYZ".

     See also:

          LTRIM$



































                                     Page - 117


                                         RUN

     Format:        RUN string1

     Description:

     This function can be used to load and execute other programs compiled with
     ASIC or another compiler.  String1 represents the name of the program to
     execute.  If an error occurs when ASIC attempts to RUN the program, it will
     set the system ERROR variable to 255.  Otherwise, the ERROR variable will
     be set to the value of the return code of the called program (which is 0
     unless the called program specifies otherwise).

     Example:

          RUN "OTHER.COM"

     Comments:

     If you are compiling with the OBJ output option, you must LINK your program
     from the command line.  This is due to the fact that, by default, LINK.EXE
     will request all available memory for the program.  When your program tries
     to RUN another program, DOS has no memory to allocate for the called
     program and the RUN will fail.  To get around this, use the "/CPARMAXALLOC"
     LINK parameter and run LINK from the COMMAND line.  You must estimate how
     much memory your program needs to load (in 16 byte paragraphs).  For
     example, to limit your program to 32k, use a LINK statement such as the
     following:
               LINK progname /CPARMAXALLOC:2000

     If you fail to specify a large enough value for "/CPARMAXALLOC", LINK.EXE
     will ignore the option and allocate all available memory, so you may have
     to experiment with this parameter to determine the proper setting.

     String1 must contain the FULL pathname of the program
     (ie,"\directory\progname.COM") only if the program is NOT in the current
     directory.  You must include the file extension on the file name (for
     example, use "MYPROG.COM" instead of just "MYPROG", or use "MYPROG.EXE"
     instead of "MYPROG").

     It is recommended (but not required) that you compile your program using
     the EXE format (instead of the COM format) when your program uses this
     statement, since an EXE program will release more memory when calling the
     program.  This will allow you to call a slightly larger program than is
     possible with the COM format.

     CAUTION:

     You may use the debugger with programs which contain "CALL" or "RUN"
     statements.  However, the programs you call should not themselves contain
     debugging code.  For example, if A.ASI calls B.ASI, then make sure you
     compile B.ASI with the "Debugging Code" option OFF before you try to debug
     program A.ASI.  Failure to do so will cause the debugger to behave

                                     Page - 118


     erratically.  This also applies to programs you write using other
     compilers, since they also use the same interrupt that ASIC uses (INT 3)
     for debugging purposes.

     See also:
               CALL
















































                                     Page - 119


                                       SCREEN

     Format:        SCREEN number1

     Description:

     This statement will transfer the computer between text mode and graphics
     modes.  Number1 must be an integer constant with a value of 0, 1, 2, 7, 9,
     or 13.  These modes are described in the table below.  The "Mode" column
     identifies the value of number1 to specify on the SCREEN command to select
     that graphics mode.  The "Graphics Resolution" column has three numbers.
     The first identifies the number of rows of pixels supported in this mode.
     The second number identifies the number of columns.  The third number
     identifies the number of colors which may displayed on screen at one time.
     The numbers in the "Text Resolution" column tell you how many rows, columns
     and colors you may display on the screen when displaying text.  The
     adapters column identifies the type of graphics adapter required to use
     this mode.

     Mode      Graphics Resolution      Text Resolution     Adapters
     -----          ------------------- ---------------     -------
       0       None                     25 x 80 x 16        Any Adapter
       1       200 x 320 x 4            25 x 40 x 4         CGA/EGA/VGA
       2       200 x 640 x 2            25 x 80 x 2         CGA/EGA/VGA
       7       200 x 320 x 16           25 x 40 x 16        EGA/VGA
       9       350 x 640 x 16           25 x 80 x 16        EGA/VGA
      13       200 x 320 x 256          25 x 40 x 16        VGA

     Example:

               SCREEN 13

     After execution of this statement, the PC will be in Graphics Mode 13 which
     will allow you to display 200 rows by 320 columns of pixels in 256
     different colors.  Up to 25 rows and 80 columns of text can be displayed in
     up to 256 colors.  And finally, mode 13 requires a VGA Graphics Card.

     Comments:

     Any program which uses the SCREEN command should issue a "SCREEN 0" command
     before terminating.  Otherwise, the screen will not be reset properly when
     you return to DOS.

     See also:

          PSET, PRESET, POINT, ZMODE








                                     Page - 120


                                        SEND

     Format:        SEND (data1,number2)

     Description:

     This statement is used to send one character to a serial port.  The port
     should initialized with OPENCOM prior to using this statement.  Data1 may
     be any valid data type (integer or string, variable or constant) and it
     should contain the character to be sent to the port.  Number2 identifies
     which COM port to send to (0=COM1, 1=COM2).

     Example:

               OPENCOM(2,0,0,3,0)
               SEND ("X",0)

     The above code will open COM1 at 300baud, 1 stop bit, 8bit character size,
     with no parity.  It will then send the character "X" to COM1.

     See also:

          RECEIVE,COMSTAT,OPENCOM































                                     Page - 121


                                       SETREGS

     Format:        SETREGS (AX,BX,CX,DX,DI,SI,BP,DS,ES)

     Description:

     This statement will set the values of CPU registers based on the values of
     ASIC variables with the same name.  If you don't want to set a particular
     register, specify NA instead of the register name.

     Example:

          AX=1
          CX=&hex0F
          SETREGS (AX,NA,CX,NA,NA,NA,NA,NA,NA)

     The above example will set the CPU register AX to 1, and set the CX
     register to 15 (hex 0F).  None of the other CPU registers are modified.

     Comments:

     WARNING:  THIS STATEMENT IS INTENDED FOR ADVANCED PROGRAMMERS ONLY.  IT IS
     POSSIBLE TO CRASH YOUR PROGRAM USING THIS STATEMENT.

     This statement is intended for use with the CODE statement.  In general,
     you can safely change the values of AX, BX, CX, DX, DI, and SI.  However,
     if you change the value of BP, DS, or ES, be sure to restore them to their
     original values before executing another ASIC statement other than CODE.

     See also:

          GETREGS, INT86, CODE, PEEK, POKE






















                                     Page - 122


                                        SOUND

     Format:        SOUND number1,number2

     Description:

     This statement will generate a sound on your computer speaker with a
     frequency of number1, and a duration of number2.  Frequency should be in
     the range of 0 to 32767.  ASIC, however, only checks to see that it is non-
     negative.

     Example:
               SOUND  400,20

     Execution of the above statement will produce a short beep.

     Comments:

     ASIC "frequencies" values go from high to low.  That is, a frequency of 0
     is the highest, and 32767 is the lowest.


                                       SPACE$

     Format:        string1=SPACE$(number1)

     Description:

     This statement will return a string containing number1 ASCII space
     characters.

     Example:

          A$=SPACE$(10)
          B$="<"+A$
          B$=B$+">"

     After execution of these statements, variable "B$" will contain the string
     "<          >".

     See also:

          STRING$











                                     Page - 123


                                        STR$

     Format:        string1 = STR$ (number1)

     Description:

     This statement will convert number1 to a string format and store the string
     format in string1.

     Example:

               A=1234
               A$ = STR$(A)

     After execution of these statements, A$ would contain the string "1234".

     See also:

          VAL


                                       STRING$

     Format:        string1=STRING$(number1,number2)  <--Format 1
                    string1=STRING$(number1,string2)   <--Format 2

     Description:

     This statement will return a string containing number1 characters of ASCII
     value number2 (Format1).  If format 2 is used, this statement will create a
     string containing number1 characters. Each of these characters will be the
     same as the first character of string2.

     Example 1:

          A$=STRING$(8,111)

     After execution of these statements, variable "A$" will contain the string
     "oooooooo".

     Example 2:

          A$=STRING$(5,"xyz")

     After execution of these statements, variable "A$" will contain the string
     "xxxxx".

     See also:

          SPACE$




                                     Page - 124


                                     SUB/ENDSUB

     Format:        SUB "subroutinename" [(parm1[[,parm2]...[,parm30]])]
                    ENDSUB [(parm1[[,parm2]...[,parm30]])]

     Description:

     These two statements are used to declare an ASIC subroutine that can be
     called using the ASIC "CALL SUB" statement.  An ASIC subroutine is compiled
     into an OBJ file.  After being compiled, you can then call it from another
     ASIC subroutine.  See Chapter 10 of the ASIC Manual for more information
     about using subroutines.

     Only one subroutine can appear in a single source file.  When declaring a
     subroutine, the SUB statement must be the very first statement in the file,
     or ASIC will generate a syntax error.  Subroutinename should be a string
     constant that will identify the name of the subroutine.  Note that
     "subroutinename" is case sensitive.

     Optionally, up to 30 parameters may be specified for the subroutine, but no
     parameters are required.

     The last statement executed in a subroutine must be the ENDSUB statement.
     This statement ensures a graceful return to the calling program.  If the
     last statement executed in a subroutine module is not ENDSUB, the results
     are unpredictable (you will probably crash your program).

     By default, the parameters are passed to the SUB "by value".  This means
     that the subroutine will copy the parameters to its own memory area, and
     will not modify the original parameters in the calling program.  This
     default behavior is achieved when the ENDSUB statement is specified with no
     parameters.

     However, if you want the subroutine to update the calling program's
     variables, you must include the same list of parameters that appeared on
     the SUB statement on the ENDSUB statement.  This will cause ASIC to update
     the calling program's copy of the variables.

     Arrays are not currently supported as parameters for SUB's.

     Example 1:

     This example shows a program to round off decimal numbers at the "cents"
     column and print it.

          SUB "PrintDollars" (NumToPrint@)

          X$=STR$(NumToPrint@)
          X$ = LEFT$(X$,16)
          X$=LTRIM$(X$)
          PRINT X$
          NumToPrint@ = 0@


                                     Page - 125


          ENDSUB

     Assume the above code is saved in a file called TESTSUB.ASI.  It should be
     compiled with the "Object Output File" compile option.

     Continuing with the example, the following code shows the calling program:

          PRINT "DOLLAR AMOUNT";
          INPUT DOL@
          CALL SUB "PrintDollars" (DOL@)
          PRINT DOL@

     Assume this program is saved in a file called CALLSUB.ASI (Note:  both
     TESTSUB.ASI and CALLSUB.ASI) are included on the ASIC disk).  When
     compiling it, be sure that the "Object Output File" compile option is set.
     Also, the "obJect Names" Compile Option should be set to "TESTSUB.OBJ".  Be
     sure that the LINK options are set so that ASIC can find LINK.EXE (see
     Chapter 10 for more information).  After you compile and link the program,
     a file "CALLSUB.EXE" should be created.  A sample execution of this program
     is shown below:

          CALLSUB <enter>
          DOLLAR AMOUNT? 530 <enter>
          530.00
                     530.00000
                       
     Note that even though the subroutine modified "NumToPrint@" to zero, the
     calling program's copy was not changed (it still printed as 530.00000).
     This is because the subroutine's ENDSUB statement had no parameters.  If
     instead, the subroutine's ENDSUB statement was "ENDSUB (NumToPrint@)", then
     ASIC would update the calling program's variable.  The same program run
     (with the new ENDSUB statement) is shown below:

          CALLSUB <enter>
          DOLLAR AMOUNT? 530 <enter>
          530.00
                       0.00000

     As expected, in this example, DOL@ has been set to 0 by "PrintDollars"
     updating the corresponding parameter variable "NumToPrint@".  (This example
     program is included on your ASIC diskette).

     Comments:

     Do not include an "END" statement in your subroutines.  This will terminate
     your program instead of returning to the calling program.  Use ENDSUB
     instead.

     Do not attempt to LINK and run an ASIC SUBroutine as a standalone program--
     it MUST be called from an ASIC program.  If you LINK and run it by itself,
     you will crash your program and probably have to reboot.  This is due to
     the ENDSUB statement.  One of the machine language instructions generated
     for ENDSUB is "RETF".  This instruction expects to find the address of the

                                     Page - 126


     calling program on the stack.  When you run a subroutine as a standalone
     program, this address is not found, and the CPU will transfer control to an
     unexpected memory location which will usually crash your program.

     The "Debugging code" compile option is not supported for SUBroutines.  When
     you compile source files containing SUB statements, ASIC will force you to
     turn off the "Debugging code" option.  This means that you cannot use the
     debugger on subroutines.  However, you can use the debugger with programs
     which call subroutines.  When tracing through a program and a CALL SUB
     statement is reached, the debugger will simply "step over" the statement.
     It cannot trace into the SUBroutine.  If your subroutine has complex logic
     and you want to use the debugger with it, then, write it as a non-
     subroutine (leave out SUB/ENDSUB statements).  Debug and test it
     thoroughly, then, add the SUB/ENDSUB statements and recompile it without
     debugging mode.

     See also:

          CALL SUB



































                                     Page - 127


                                        TIME$

     Format:        string1 = TIME$

     Description:

     This statement will retrieve the current time from the PC's system clock.
     The time will be retrieved and stored in String1, in the format:
     "HH.MM.SS".

     Example:

          CURTIME$=TIME$
          PRINT CURTIME$

     After execution of the above statements the current time (as per the PC's
     internal clock) will be displayed on the screen.

     Comments:

     Note:  if the time printed is wrong, you have probably not set the system
     clock.  Most older XTs and PCs do not have a battery to preserve the DATE
     and TIME in the system clock, so you have to set them each time you power
     up the PC.  Most ATs and newer PCs have a battery backup, so that the date
     is preserved for you.

     Unlike GWBASIC/BASICA, you cannot set the system time with TIME$, however,
     you can set the system time from DOS by typing TIME.

     See also:

          DATE$, TIMER






















                                     Page - 128


                                        TIMER

     Format:        number1 = TIMER

     Description:

     This statement will retrieve a timer count from the PCs hardware circuitry.
     The timer count will be placed in number1.  The timer count is in "clock
     ticks".  A "clock tick" occurs in the PC approximately 18.2 times per
     second.  The PC is continually incrementing this clock counter.  This
     statement can be used to time the duration of events.

     Example:

          CLS
          PRINT "PRESS A KEY"
          STARTCNT&=TIMER
     LOOP:     X$=INKEY$
          IF X$="" THEN LOOP:
          ENDCNT&=TIMER
          ELAPSED&=ENDCNT&-STARTCNT&
          ELAPSED&=ABS(ELAPSED&)
          ELAPSED&=ELAPSED&/18
          PRINT "IT TOOK YOU APPROXIMATELY";
          PRINT ELAPSED&
          PRINT " SECONDS TO PRESS A KEY"

     The above code fragment will time how long you wait to press a key in
     seconds.  You could modify it easily to display in clock ticks, which would
     provide much more accuracy, if you deleted the statement which divides the
     ELAPSED count by 18.

     Comments:

     Note that it is necessary to use the absolute value of ELAPSED& since the
     clock counts is stored as unsigned integers.  ASIC integers, on the other
     hand, are signed.  If number1 is a long integer variable, then TIMER
     retrieves the full PC timer value.  However, if a normal integer variable
     is specified as number1, then ASIC retrieves the least 16 significant bits
     from the PC timer.

     See also:

          DATE$,TIME$










                                     Page - 129


                                       UCASE$

     Format:        string1=UCASE$(string2)

     Description:

     This statement will convert all lowercase letters in string2 to uppercase,
     and store the resulting string in string1.

     Example:

          A$=UCASE$("123 Main St, USA")

     After execution of this statement, the variable "A$" will contain the
     string "123 MAIN ST, USA".

     See also:

          LCASE$


                                         VAL

     Format:        number1 = VAL (string1)

     Description:

     This statement will attempt to convert string1 into an integer value, and
     it will store the result in number1.

     Example:

               A$ = "12345"
               A = VAL (A$)

     After execution of these statements, variable "A" would contain the value
     12345.

     See also:

          STR$













                                     Page - 130


                                       VARPTR

     Format:        number1 = VARPTR (variable1)

     Description:

     This statement will return the address of a variable  variable1 and store
     it in number1.  This may be used to peek and poke values directly into a
     variable.

     Example:

               A$ = "XYZ"
               B = VARPTR(A$)
               C = PEEK (B)
               PRINT C

     After execution of these statements the screen would display the number 88
     which is the number for the ASCII character "X".

     See also:

          PEEK, POKE


                                     WHILE/WEND

     Format:        WHILE condition
                    WEND

     Description:

     This statement will execute those statements which are between the WHILE
     and the WEND statements as long as the "condition" is true.  The operand
     "condition" is one of the following:

          number1 > number2        number1 >= number2
          string1  > string2       string1  >= string2
          number1 = number2        number1 <> number2
          string1  = string2       string1  <> string2
          number1 < number2        number1 <= number2
          string1  < string2       string1  <= string2

     Example:

               PRINT "PRESS A KEY TO CONTINUE"
               A$=""
               WHILE A$=""
                    A$=INKEY$
               WEND

     In this example, the program will pause until the user presses a key.
     WHILE statements may be nested 25 levels deep.

                                     Page - 131


                                        WIDTH

     Format:        WIDTH number1

     Description:

     This statement will set the screen to 40 column text or 80 column text mode
     only.  The only two valid values for number1 are thus 40 and 80.  In ASIC,
     WIDTH 80 is equivalent to executing SCREEN 0.  Also, WIDTH 40 is equivalent
     to executing SCREEN 1.  If you use WIDTH 40, you should always reset the
     screen back to WIDTH 80 before terminating your program with END.
     Otherwise, your PC will be left in 40 column mode.

     Example:

          WIDTH 40

     The above statement would put the PC in 40 column mode.


                                        ZBIT

     Format:        number1 = ZBIT(number2,number3)

     Description:

     This statement is used to determine if a single "bit" in an integer
     variable is set to "1".  Number2 represents the bit to be tested.  It
     should be in the range 0 to 15.  Number3 represents the integer variable or
     constant to be tested.  The result of the test is returned to number1.  If
     the bit was set, number1 will be set to "1", otherwise, number1 will be set
     to "0".

     Example:

               GAMEPORT = INP(513)
               TRIGGER = ZBIT(4,GAMEPORT)
               IF TRIGGER = 1 THEN TRIGGERPRESSED:

     In this example, the joystick port is read, and its status is placed in the
     variable "GAMEPORT".  The bit which represents the trigger for joystick 1
     is then tested using ZBIT.  If the trigger bit is set, then
     the program would transfer to the label "TRIGGERPRESSED:".  Note that the
     above code assumes that a game card is present in the computer.

     Comments:

     This statement is an extension over GWBASIC/BASICA, although it is possible
     to perform similar tests in GWBASIC/BASICA with the boolean AND statement.





                                     Page - 132


                                        ZMODE

     Format:        integer = ZMODE

     Description:

          This command returns a code which indicates whether a color or
     monochrome card is active in the system.  ZMODE returns a value of 1 when a
     color card is detected, and a value of 0 for monochrome.

     Example:

               A = ZMODE
               IF A = 0 THEN
                    PRINT "This program requires a Color Card to Run"
                    END
               ENDIF

     The above code fragment will check for a color card; if not found, the
     program will terminate with an appropriate message.  Otherwise, the program
     will continue.

     Comments:

     This statement is an extension over BASICA/GWBASIC.





























                                     Page - 133


                                       A S I C

                                      Chapter 8

                          Compatibility with GWBASIC/BASICA


     In general, although ASIC does not support all options on every BASIC
     statement, those it does support work like they do in BASICA/GWBASIC.  The
     known exceptions are listed in this chapter.

     INKEY$

     This statement is compatible, however ASIC does provide an extension over
     GWBASIC/BASICA.  If an extended key is pressed (e.g. F1-F10), ASIC returns
     the scan code for the extended key, and sets a special system variable
     "EXTENDED" to a value of 1.  For non-extended keys, the "EXTENDED" variable
     will contain 0.

     FILE HANDLING

     ASIC provides no EOF statement or ON ERROR statements.  Instead, ASIC sets
     a special system variable when an error occurs during file I/O.  This
     special variable is called "ERROR" and it is set after every file I/O
     statement (OPEN/INPUT#/PRINT#/CLOSE, etc.) to either 0 to indicate no
     errors, or a non-zero value.  If a non-zero value is present, an error has
     occurred.  The specific errors are identified in chapter 10.

     FILE FORMAT

     ASIC Files are written with 2/4 bytes per normal/long integer in binary
     format, instead of string format as in BASICA/GWBASIC.  Strings are written
     as a sequence of ASCII characters terminated by an ASCII null, or
     optionally with no NULL terminator.

     PUNCTUATION

     ASIC permits use of punctuation that it does not require to allow you to
     enter statements in their familiar GWBASIC/BASICA Formats.  For example:

               A = ABS (B(1))

     This statement is valid in both ASIC and in GWBASIC/BASICA.  However, ASIC
     ignores the parenthesis and comma.  Thus ASIC will actually accept the
     following formats as alternatives to the above:

          A = ABS B 1
          A = ABS B 1,,,,,,)))))

     FOR/NEXT




                                     Page - 134


     FOR/NEXT loops always fall through the body of the FOR at least one time in
     ASIC.  This does not happen in BASICA/GWBASIC.  For more information on
     this, refer to Chapter 7.

     RND

     RND (N) returns a value from 0-32767 for normal integers and     0-
     2,147,483,647 for long integers instead of 0 to 1 as in BASICA/GWBASIC.

     LOCATE/CSRLIN/POS

     Coordinates are specified in range 0-24 and 0-79 instead of 1-25 and 1-80.

     PSET/PRESET/POINT

     Coordinates are specified in row/column order instead of column/row order.

     BLOAD/BSAVE

     File formats are not compatible with GWBASIC/BASICA.  BLOAD requires offset
     and the number of bytes to read.

     OPENCOM/COMSTAT/SEND/RECEIVE

     These statements provide serial port support in ASIC.  In GWBASIC/BASICA
     this is provided by OPEN/INPUT#/PRINT#.

     DATE$/TIME$

     ASIC allows you to retrieve the system date and time, but will not allow
     you to set new system date/time values.

     CALL/RUN

     These statements perform functions similar to their GWBASIC/BASICA
     counterparts, but function differently.  Refer to the keyword reference for
     the appropriate keyword for details on their operation.

     EXTENSIONS OVER BASICA/GWBASIC

     CODE                COMMAND$
     INT86               FILEPOS
     FIND                LCASE$
     LTRIM$              MOD
     RTRIM               UCASE$
     ZBIT                ZMODE
     EXTENDED            FILELEN
     GETREGS             SETREGS
     GETDRIVE            SUB
     ENDSUB

     The statements above are extensions over BASICA/GWBASIC.


                                     Page - 135


                                       A S I C

                                      Chapter 9

                               Technical Details/Tips


     This chapter contains technical information and tips regarding ASIC.

                                   COMPILER LIMITS

     Maximum Source Program Size:   Command Line Compiler - Unlimited
                                    Integrated Environment - Limited only by
                                    available memory

     Maximum Object Program Size:   64k bytes--.COM Format:
                                   64k code/data/stack
                                   130k+ bytes--.EXE Format:
                                             64k code
                                             64k data
                                             up to 64k stack
                                   130k+ bytes--.OBJ Format:
                                             64k ASIC code
                                             64k ASIC data
                                             up to 64k stack
                                             PLUS up to ~500k externally
                                             assembled ".OBJ" files can
                                             be linked into your ASIC
                                             program and called using
                                             the CALL SUB statement.
     Maximum Source Line Length     128 bytes - Command Line
                                    80 bytes - Integrated Environment

     Compiler Symbol Table Size:    Unlimited - can use all available memory

     Maximum Number of Arrays:      25

     FOR/NEXT Nesting Depth         25

     IF/THEN/ELSE Nesting Depth     25

     WHILE/WEND Nesting Depth       25

     Compiler Memory Requirements  425k

     Subroutines per source file   Unlimited


                                 COMPILER OPERATION

     ASIC is a single pass compiler written in C (Borland C Version 3.1).  Each
     source statement is translated directly into machine code.  ASIC compiles
     100% in memory for maximum speed.  The compiler does not require any disk

                                     Page - 136


     work space.  ASIC generates a minimum of error checking code.  This is
     because the ASIC philosophy stresses execution speed.  This does place
     greater responsibility on the programmer to check for out of bounds
     conditions, etc....


















































                                     Page - 137


                                 MEMORY OPTIMIZATION

     ASIC provides 32 bit long integers in addition to 16 bit normal integers.
     This allows you to store much larger numbers, however, nothing in life is
     free.  Long integers will increase the size of the resulting ".COM" file by
     approximately 475 bytes.  If you are not using long integers, be sure to
     compile with the "Extended Math" Option turned OFF so that ASIC does not
     include these unneeded bytes in your COM or EXE file. Otherwise, ASIC will
     include the long integer support code in your file, even if you never
     create a single long integer!  Note: by default, this option is turned off
     in both the command line and integrated versions of the compiler.

     Likewise, the "Decimal Math" option will allow math with fractional results
     of very large numbers, but this option will increase your program size.
     Use integers or long integers unless you need this fractional precision,
     and turn off the "Decimal Math" option.  Note:  by default, this option is
     turned off in both the command line and integrated versions of the
     compiler.

     Also remember that ASIC's debugging option increases your ".COM" file size.
     So don't forget to recompile your program with the "Debugging" Option
     turned off (after you have finished debugging it, of course).

     COM disk files will usually be smaller than EXE files by several hundred
     bytes.  However, COM files require 64k of memory to execute.  Additionally,
     COM files (because of a DOS requirement), will automatically allocate all
     available memory at load time.  EXE files require the actual size of the
     program plus 2000 bytes for the stack (4000 bytes for the stack when
     compiling with debugging mode).  Thus, your program may be loadable in as
     few as 3-4k bytes of memory.  Also note that an ASIC EXE does NOT allocate
     all available memory to your program.  ASIC only allocates the amount of
     memory your program actually needs.  The following chart summarizes when it
     is usually best to use each type of file:

          Use COM files when:
          -------------------

          o  You want to minimize the disk space a program occupies
          o  Your program is smaller than 64k in size

          Use EXE files when:
          -------------------

          o  Your program is larger than 64k in size
          o  You want to minimize your program's run-time memory requirements
          o  You are calling another program using the RUN or CALL Statements

          Use the OBJ option to create an EXE file when:
          ----------------------------------------------

          o using the CALL SUB statement.



                                     Page - 138


                              PERFORMANCE OPTIMIZATION

     This section contains tips for making your programs run as fast as
     possible.

     1)   VARIABLE TYPES - Don't use long integer variables or decimal variables
     to store numbers that can fit in a regular integer variable.  Long integer
     variables are exponentially slower than regular integers, and decimal
     variables are exponentially slower than long integer variables.  If the
     number will exceed the range allowed by a regular integer, but is an
     integer in the range +/-2,147,483,647, then use a long integer.  If the
     number requires one or more decimal places of precision, or is an integer
     larger than +/-2,147,483,647, then use a decimal variable.  Always use
     integers on FOR/NEXT loops, when possible.

     2)   DECIMAL VARIABLES - When using decimal variables, be aware that the
     least efficient operation is screen I/O.  Don't PRINT a number unless you
     need to. (Note:  The decimal variable format used by ASIC was selected to
     optimize speed when adding, subtracting, multiplying, and dividing.  The
     trade off in using this format is that it takes longer to convert the
     internal format to printable form than it would have with a packed binary
     coded decimal (BCD) format.)

     3)   MATH FUNCTIONS - The math functions, in order of least efficient to
     most efficient, are:  Division, Multiplication, Subtraction and Addition.

     4)   DON'T MIX VARIABLE TYPES - When performing calculations using decimal
     variables, avoid mixing decimal variables with integer variables.  Although
     ASIC will automatically convert the integers to a decimal format
     internally, this conversion will slow down your calculations.


                                   DEBUGGER LIMITS

     Maximum Concurrent Breakpoints     20

     Maximum Concurrent Watches         10

     Maximum Symbol Length              30 Characters

     Maximum Symbols                    Same as Compiler

     Maximum Source Statements          Unlimited


                                 DEBUGGER OPERATION

     When you select the "Debugging code" compiler option, the ASIC compiler
     inserts additional machine language instructions into your program.  It
     inserts a single statement at the beginning of your program (specifically,
     INT 3) which allows it to gain control.  When the ASIC editor is loaded, it
     saves the existing INT 3 vector, and installs the ASIC Debugger as INT 3.
     In this way, when your program begins executing, the INT 3 statement that

                                     Page - 139


     ASIC inserted in your program causes a transfer of control to the debugger.
     Once the debugger gains control, it can set or remove additional
     breakpoints as needed in your program, plus provide access to the video
     memory and variable memory locations with the Swap, Watch, Unwatch, and
     Modify Commands.  When you exit the ASIC editor, ASIC deinstalls the
     debugger from INT 3, and restores the original interrupt 3 vector.

     The compiler also creates a file with a ".DBG" extension which contains the
     symbolic information needed by the debugger (i.e., variable names and
     offsets, and source statement offsets).

                                  DEBUGGER OVERHEAD

     Running a program in debugging mode adds a small amount of overhead to your
     program (both compiled code size, and execution speed).  Specifically, the
     size of the debugging code will be (approximately):

               CodeSizeIncrease = 1 + LinesOfSourceCode

     Note that the actual increase will usually be less than the above, since
     DIM, DATA, REM, and blank source lines do not require debugging code.  The
     reduction in execution speed is very slight in most cases (for you assembly
     language programmers out there, a single NOP instruction is executed for
     each source line).

     In EXE files, the stack size is increased by an additional 2k when
     debugging is enabled.


                                  BAS2ASI OPERATION

     BAS2ASI is ASIC's GWBASIC Program Conversion Utility (see Chapter 11 for
     more information on using BAS2ASI).  BAS2ASI is a two pass converter.  Pass
     1 (B2A1.EXE) performs the raw conversion of GWBASIC statements to ASIC
     statements.  During pass 1, two files are created (filename.TMP and
     filename.LBL).  The ".TMP" file contains the raw, unoptimized converted
     statements.  The ".LBL" file contains the list of program labels which were
     referenced in the GWBASIC program.  After pass 1 completes BAS2ASI calls
     Pass 2 (B2A2.EXE) to conduct the code optimization.  During this pass,
     unused labels are stripped from the program, and other statement
     optimizations are performed.  The optimized program is then written to
     filename.ASI, and filename.TMP and filename.LBL are deleted.


                                   STORAGE FORMATS

     NORMAL INTEGERS are stored in ASIC as two bytes, with the low order byte
     appearing first (as per Intel conventions).

     LONG INTEGERS are stored in ASIC as four bytes, with the least significant
     word first, followed by the most significant word.  Within these two words,
     the least significant byte appears first followed by the most significant
     byte.

                                     Page - 140



     STRING VARIABLES are stored as FIXED 80 character strings terminated by an
     ASCII null character for a total length of 81 characters.

     STRING CONSTANTS are stored with 1 byte per character in the string
     followed by a terminating ASCII null character.

     DECIMAL VARIABLES AND CONSTANTS are stored in 8 bytes, from least
     significant byte to most significant byte.  They are stored as signed
     binary integers, with an implicit decimal point.  The integer values are
     adjusted after each multiplication or division to scale the result to the
     proper number of decimal places.

     ARRAYS - Each element in an array requires two bytes.  (Don't forget arrays
     have an element zero (i.e.  DIM A(2) is comprised of A(0), A(1), and A(2)).

     Examples:

               Item           Data Type           Storage Requirements
               A              Integer Variable         2 bytes
               17             Integer Constant         2 bytes
               A&             Long Integer Variable    4 bytes
               55555&         Long Integer Constant    4 bytes
               A$             String Variable          81 bytes
               "ABC"          String Constant          4 bytes
               "A"            String Constant          2 bytes
               A@             Decimal Variable         8 bytes
               1.23456        Decimal Constant         8 bytes
               12345@         Decimal Constant         8 bytes
               DIM A(10)      Integer Array            22 bytes
               DIM A(1)       Integer Array            4 bytes
               DIM A&(10)     Long Int Array           44 bytes
               DIM A$(10)     String Array             891 bytes
               DIM A@(10)     Decimal Array            88 bytes

     As you can see, string variables are expensive in terms of storage space.
     Since string constants are stored at actual length +1, It is MUCH more
     efficient to store short strings as constants in ASIC in terms of storage
     space.  There is no performance advantage to constants over variables,
     however.

     In disk files, strings, decimals, and integers are written out in the above
     formats.  Note that unlike GWBASIC/BASICA, integer and decimal values are
     NOT expanded into strings when written, and conversely, not converted from
     strings when read.  String variables and constants are written out as ASCII
     strings terminated by a null character (however, the null can be
     suppressed).  Thus, string variables when written to disk, take the same
     space byte for byte as string constants.

     The reason behind fixed length string variables was avoidance of string
     "garbage collection".  In addition to slight performance advantages, there
     is the added benefit of providing a string memory address which never


                                     Page - 141


     changes.  Thus once VARPTR retrieves the address of a variable, you never
     have to worry about it changing.




















































                                     Page - 142


                                     MEMORY MAP

     COM File Memory Map

     The following describes the structure of the ".COM" file created by ASIC.
     All addresses are in Hexadecimal.


          Description                        Address Range
     ------------------------------          -------------
     Program Segment Prefix (PSP)            0000 - 00FF
      (Created/Required by DOS)

     Transfer to Program Code                0100 - 0102
     String Conversion Buffer                0103 - 0109
     Input Buffer                            010A - 015B
     Screen Width                            015C
     Color/Attribute Byte                    015D
     Screen Graphics Mode                    015E
     Cursor Position                         015F - 0160
     File Control Table                      0161 - 0169
     ERROR System Variable                   016A - 016B
     System Subroutine Vectors               016C - 017F
     EXTENDED System Variable                0180 - 0181
     RND Seed                                0182 - 0185
     Math Work Area                          0186 - 018D
     DEFSEG System Variable                  018E - 018F
     Start DATA Block Pointer                0190 - 0191
     Current DATA Block Pointer              0192 - 0193
     Reserved for future use                 0194 - 0195
     Optional Sys Subroutine Vectors         0196+
     and Work Areas (decimal math option)
     System Subroutines                      Address Varies
               |
               |
               v
     Data Segment                            Address Varies
               |
               |
               |
               v
     Code Segment                            Address Varies
               |
               |
               |
               v
               ^
               |
               |
     Program Stack  (builds downward)        FFFF




                                     Page - 143


     EXE File Memory Map

     The following describes the structure of the ".EXE" file created by ASIC.
     In the COM file format the code, data, and stack are all in the same memory
     segment.  In an ASIC EXE format file, the code, data, and stack each reside
     in their own segment.  Addresses are given as offsets from the CS (Code
     Segment), DS (Data Segment), or SS (Stack Segment) registers.


          Description                        Address Range
     ------------------------------          -------------
     Program Segment Prefix (PSP)            CS: minus 00FF
     (Created/Required by DOS, and
     immediately precedes the
     code segment)
               |
               |
               v
     Code Segment (CS:)
          User Program                       0000 +
               |
               |
               v
          System Subroutines                 Address Varies
               |
               |
               v
     Data Segment (DS:)
          Program Data Area #1               0000 - 0102
          String Conversion Buffer           0103 - 0109
          Input Buffer                       010A - 015B
          Screen Width                       015C
          Color/Attribute Byte               015D
          Screen Graphics Mode               015E
          Cursor Position                    015F - 0160
          File Control Table                 0161 - 0169
          ERROR System Variable              016A - 016B
          System Subroutine Vectors          016C - 017F
          EXTENDED System Variable           0180 - 0181
          RND Seed                           0182 - 0185
          Math Work Area                     0186 - 018D
          DEFSEG System Variable             018E - 018F
          Start DATA Block Pointer           0190 - 0191
          Current DATA Block Pointer         0192 - 0193
          Reserved for future use            0194 - 0195
          Optional System Sub Vectors        0196+
          and Work Areas (decimal math option)
          Program Data Area #2               Address Varies
               |
               |
               v
     Stack (SS:)  (builds downward)          0000 - 07D0 (0FA0--debug mode)


                                     Page - 144


               NOTE:  The format of an EXE file created using the
               "B/OBJ" option is essentially the same as the one
               produced by the "B/EXE" option, except that the "B/OBJ"
               output file may contain additional code or data
               segments linked in from other OBJ or LIB files.

















































                                     Page - 145


                                       A S I C

                                     Chapter 10

                           Multiple Object Module Programs

                                      OVERVIEW

     ASIC programs can incorporate subroutines you write in ASIC or assembly
     language.  This is a powerful feature, but it is a bit complicated until
     you have done it a few times.  This chapter describes how to use the CALL
     SUB statement to call separately compiled subroutines.


                                  ASIC SUBROUTINES

     If you are developing an ASIC subroutine, all you need is ASIC, and a
     linker such as MS DOS LINK or Borland's TLINK.  Creating an ASIC subroutine
     is described in Chapter 7 ("SUB/ENDSUB" statements).  This chapter will
     provide additional information for compiling the subroutine and
     incorporating it in your ASIC programs.  ASIC subroutines are much easier
     to develop than assembler subroutines.

                                ASSEMBLER SUBROUTINES

     For Assembly Language subroutines, you need:  ASIC, and a linker such as MS
     DOS LINK or Borland's TLINK.  You will also need an assembler such as
     Borland's Turbo Assembler or Microsoft's Macro Assembler.  Later in this
     chapter we'll describe the details of building an Assembly language
     subroutine.


                      BUILDING PROGRAMS WITH MULTIPLE OBJ FILES

     The main difference between developing subroutines in ASIC or Assembly
     Language is the coding of the subroutine itself.  Once the subroutine has
     been written, the process of building the ASIC program is very similar.

     In both cases, the "CALL SUB" statement is used to call the subroutine--it
     doesn't matter if you are calling ASIC subroutines or Assembler
     subroutines, the syntax of the CALL SUB statement is the same for both.

     You can also store multiple .OBJ files into one or more .LIB files (if you
     have a program such as Microsoft's LIB or Borland's TLIB) and use the
     "Library Names" compile option. (see Chapter 5)

     To help you get started, ASIC includes two sets of sample files that
     contain everything you need to create a working sample ASIC and Assembler
     subroutine.

     ASIC Sample Files

          CALLSUB.ASI         <--Program to call ASIC subroutine

                                     Page - 146


          CALLSUB.PRJ         <--Project file for CALLSUB.ASI
          TESTSUB.ASI         <--ASIC subroutine called by CALLSUB.ASI
          TESTSUB.PRJ         <--Project file for TESTSUB.ASI

     Assembler Sample Files

          CALLSRCH.ASI   <--Program to call Assembler subroutine
          CALLSRCH.PRJ   <--Project file for CALLSRCH.ASI
          SRCH.ASM       <--Assembler subroutine called by CALLSRCH.ASI

     We'll go through the process of building the ASIC subroutine version first.
     Then, we'll build the assembly language version.  Finally, we'll describe
     requirements for assembler language subroutines.


                        BUILDING THE ASIC SUBROUTINE SAMPLES

     Make sure the sample files (TESTSUB.PRJ, TESTSUB.ASI, CALLSUB.PRJ,
     CALLSUB.ASI) are in your ASIC working directory for purposes of this
     example.  Also, copy the LINK.EXE file which comes with MS DOS to your ASIC
     directory or to the directory "C:\DOS".  Note:  if you don't want to make a
     copy of LINK.EXE, you don't have to, but you need to tell ASIC how to find
     LINK.EXE by using the LNK= compile option (see Chapter 5 command line
     options, or the ADVANCED MENU OPTIONS section in chapter 3, for information
     on setting the LINK path).

     The first step is to compile all of the subroutine files.  Their are two
     compiler options which ASIC will force you to use with subroutine files.
     The "Object Output Files" option must be set.  The "Debugging Code" option
     must be turned off.  The TESTSUB.PRJ file already has these set properly,
     but you need to know about them for future projects.   To build the object
     file from the integrated environment type:

                    ASIC TESTSUB <enter>
                    <F10>

     You shouldn't get any compiler errors, so press <enter> to clear the "No
     Errors" message box.  Then, you can exit ASIC.

                    <Alt><x>

     If you prefer to build the subroutine from the command line compiler, type:

                    ASICC TESTSUB.PRJ <enter>

     Regardless of which of the two approaches you followed, the result is that
     ASIC has compiled your subroutine into the file "TESTSUB.OBJ".  You are now
     ready to compile the calling program.

     To build it from the command line, type:

                    ASICC CALLSUB.PRJ <enter>
                    or

                                     Page - 147


                    ASICC CALLSUB B/OBJ OBJ=TESTSUB <enter>

     To build it from the integrated environment, type:

                    ASIC CALLSUB <enter>
                    <F10>

     You shouldn't get any compiler errors, so press <enter> to clear the "No
     Errors" message box.  Then, you can exit ASIC.  If you did get an error, it
     was probably because ASIC could find LINK.EXE (see above).  The following
     statement will exit ASIC:

                    <Alt><x>

     The CALLSUB.PRJ file took care of a couple details for you automatically.
     First, it set the "Object Output File" compiler option.  When using CALL
     SUB this option must always be set.  Second, it identified the name of the
     ".OBJ" file containing the subroutine we are calling, in this case
     "TESTSUB.OBJ".  This option is set with the "Object Names" option on the
     advanced compiler menu.  CALLSUB and TESTSUB are described in Chapter 7
     under the SUB/ENDSUB statements.  So if you want more information about
     them, check there.  The program can be run now if you want.  To do so, just
     type "CALLSUB <enter>".


                      BUILDING THE ASSEMBLER SUBROUTINE SAMPLES

     The file CALLSRCH.ASI is an ASIC program which calls a subroutine called
     SRCH.  SRCH.ASM is the source to an assembly language program.  Make sure
     these files (and CALLSRCH.PRJ) are in your ASIC working directory for
     purposes of this example.  Also, copy the LINK.EXE file which comes with MS
     DOS to your ASIC directory or to the directory "C:\DOS".  Note:  if you
     don't want to make a copy of LINK.EXE, you don't have to, but you need to
     tell ASIC how to find LINK.EXE by using the LNK= compile option (see
     Chapter 5 command line options, or the ADVANCED MENU OPTIONS section in
     chapter 3, for information on setting the LINK path).

     The first step in producing the EXE file is to assemble the SRCH.ASM
     program.  If you have Borland's Turbo Assembler, type:

          TASM SRCH <enter>

          Otherwise, if you have Microsoft's Macro Assembler, type:

          MASM SRCH <enter>

     This should create a file called SRCH.OBJ in your working directory.  The
     second step is to build the ASIC program.  If you prefer the ASIC command
     line compiler, you can accomplish the build with a single command:

          ASICC CALLSRCH B/OBJ OBJ=SRCH <enter>
          or
          ASICC CALLSRCH.PRJ <enter>

                                     Page - 148



     That's all there is to it, if you are building from the command line.  You
     should be able to run the program now, try it--type:

          CALLSRCH <enter>

     Read the comments in the programs for a description on what the program
     does.  You can also accomplish this easily from the integrated environment.

          First, load the program into ASIC:

          <Alt><f>
          <o>
          CALLSRCH <enter>

          The above opens the "file" menu, selects the "open" option, and
     selects the file "CALLSRCH.ASI".  Next, set the compiler options:

          <Alt><c>
          <a>
          <o>
          <j>
          SRCH <enter>

          This opens the  "compile" menu, selects the "advanced options" menu,
     sets the file output type to "obj" and set the "obJect names" to "SRCH".

          <Alt><f>
          <s>

          This opens the "file" menu, and selects the "save" option.  This not
     only saves the CALLSRCH.ASI file to disk, it also saves all of the compile
     options you just set, to a file called CALLSRCH.PRJ.  So, the next time you
     enter ASIC, you won't have to re-set all those options for this program.

          Now compile the program:

          <F10>

          You should see the ASIC compiler screen compile the program, and you
     should then see a few messages as the Microsoft LINK program builds the EXE
     file.  In the future, from the integrated environment, you can rebuild the
     CALLSRCH program by loading it into the edit buffer and pressing <F10> to
     compile.  ASIC will remember all of the options you told it, so it will
     remember to link the "SRCH" module, automatically.


                        ASSEMBLY LANGUAGE SUBROUTINE OVERVIEW

     Now that you know how to build the program we'll step back and explain how
     to develop and use assembler subroutines.  Four steps are required:

          1)  DEVELOPING ASSEMBLER SUBROUTINES

                                     Page - 149


          2)  ASSEMBLING YOUR SUBROUTINE
          3)  DEVELOPING THE CALLING ASIC PROGRAM
          4)  BUILDING THE EXECUTABLE PROGRAM


                          DEVELOPING ASSEMBLER SUBROUTINES

          The first step is to develop an assembler subroutine.  There are
     several things you need to be aware of, when developing an assembler
     program:

     1)   The entry point must be declared using the PUBLIC keyword.  If you do
     not do this, you will receive a linker error.

     2)   ASIC saves most critical registers prior to the CALL, however, in your
     assembler subroutine, you must take care to preserve the value of the SS
     and SP registers.  When you return to ASIC from your subroutine, you must
     insure that the SS and SP register values have not changed.  This means
     that if you PUSH any values to the stack, you MUST POP them before the
     return instruction to ASIC.  Failure to do so will almost always crash your
     program.

     3)   ASIC calls external assembler subroutines using FAR calls
     (segment:offset), so you must declare the PROC as FAR, and must use the
     RETF (far return) instruction to return to ASIC.

     4)   ASIC passes parameters on the stack as far pointers (by reference).
     This means, that regardless of whether the parameter being passed is a
     short integer, long integer, or string, ASIC will always place 4 bytes on
     the stack.  ASIC always pushes the segment portion (2 bytes) of the pointer
     to the stack first, followed by the offset (2 bytes).  Remember that these
     4 bytes are not the value of the variable, but a pointer to the variable in
     memory.  If you look at the memory location pointed to by these 4 bytes,
     you will find the starting location of the variable.  ASIC passes variables
     from the CALL SUB statement from left to right.

     5.   When your subroutine receives control from ASIC, the stack will look
     like the following:

          etc.
          SS:SP+10  (2 bytes) segment of next-to-last parameter
          SS:SP+8   (2 bytes} offset of next-to-last parameter
          SS:SP+6   (2 bytes) segment of last parameter
          SS:SP+4   (2 bytes) offset of last parameter
          SS:SP          (4 bytes) return address

     6) If your ASIC calling program passes constants to a subroutine, be aware
     that the subroutine can update the memory location used to store the
     constant values.  For example, if you modify the memory location used by
     ASIC to store the value of the constant "1" to "2", you will have
     inadvertently redefined the constant "1" to "2" throughout your ASIC
     program.  If you are not sure if a parameter will be updated by a
     subroutine, play it safe, use a variable for the parameter.

                                     Page - 150



                             ASSEMBLING YOUR SUBROUTINE

          Before you subroutine can be used, it must be assembled.  Use your
     favorite assembler to do so.  If you like, you can store your object files
     in Microsoft LIB compatible format files for convenience.


                         DEVELOPING THE CALLING ASIC PROGRAM

          All that you have to do to call the subroutine, is insert a CALL SUB
     statement in your program.  The CALL SUB statement has the following
     format:

               CALL SUB "subroutinename" [parm1...parmN]

          Where "subroutinename" is the name of the subroutine you wish to call
     (it must be in quotes).  No parameters are required, but you may provide
     one or more, if you like.  Any valid ASIC variable or constant type may be
     passed as a parameter.  "subroutinename" must match the name of the PUBLIC
     PROCedure you declared in your assembly language subroutine.

                           BUILDING THE EXECUTABLE PROGRAM

          Finally, you have to build the program.  You must do the following
     steps to create a valid EXE file:

          o  Load the edit buffer with the calling ASIC program
          o  Select the "Obj output file" option.
          o  Identify the names of any object modules to be linked with your
             ASIC program, if any.
          o  Identify the names of any object libraries to be linked with
             your ASIC program, if any.
          o  Tell ASIC where to find the MS DOS Linker
          o  Compile your program--ASIC will call the DOS linker
             automatically.


                                 OTHER LINK OPTIONS

          The above is a simple example; there are other compile examples in
     Chapter 5.  If you have one or more subroutine object modules stored in a
     library, you can use the "LIB=" option on the command line to specify the
     library names to ASIC.  You can also specify the library information inside
     the integrated environment (Open the "compile" menu, select the "Advanced
     options" option.  From the "Advanced options" menu that pops up, select the
     "liBrary names" option.

          When specifying object files, remember that the ".OBJ" file extension
     is optional, as is the ".LIB" extension on library files.  You don't have
     to give the full file spec (i.e., disk drive and directory) if the file is
     in the ASIC directory.  See Chapter 3 and Chapter 5 for more information on


                                     Page - 151


     setting these options from the integrated environment and command line
     compiler respectively.

                                      DEBUGGING

          You can use the debugger on ASIC programs which use the CALL SUB
     statement, however, you can't "trace into" the subroutine instructions.
     When you press <F8> to trace one line, and you are positioned on a CALL SUB
     statement, the CALL SUB is executed, and ASIC advances to the next ASIC
     statement following the CALL SUB.  The called subroutine should not contain
     debugging (i.e., "INT 3" in assembler) instructions.  If they do, the
     debugger will behave erratically (this can never happen with ASIC
     subroutines--only with assembler subroutines).









































                                     Page - 152


                                       A S I C

                                     Chapter 11

                     Converting GWBASIC Programs to ASIC Format

                                      OVERVIEW


     ASIC includes a utility (BAS2ASI) that will help you convert your GWBASIC
     programs to ASIC format.  BAS2ASI can often perform much of the conversion
     necessary and will notify you with warnings and error messages where
     further attention is required.


                      Converting In The Integrated Environment

     Converting GWBASIC programs to ASIC format is easy in the integrated
     environment.  From the File Menu, select the Convert Option.  A file dialog
     box will be displayed.  Select the file to be converted from the list, or
     type in the file name and press <enter>.

     BAS2ASI will convert the file to a file with the same name, but with a
     ".ASI" file extension.  Note, if a file with the same name and an ".ASI"
     extension already exists, it will be overwritten.

     Note:  The file must have been saved in ASCII format (i.e., SAVE
     "filename.BAS",A).

     BAS2ASI has several options to allow you to control how much information is
     written to the convert file (Comments, Warnings, Errors).  These are
     described in Chapter 3.

     After the file is converted, ASIC will load the file into the ASIC edit
     buffer. (Note: a sample GWBASIC program AREA.BAS is included on your ASIC
     disk).


                          Converting From the Command Line

     You can also run BAS2ASI from the command line.  The syntax for this is:

     BAS2ASI filename.BAS [option] [option] [option]

     where option=  NOCOMMENTS     don't write original source to output as REMs
                    NOWARNINGS     suppress warnings in output file
                    NOERRORS       suppress error messages in output file
     Examples:
               BAS2ASI TEST.BAS
               BAS2ASI TEST.BAS NOCOMMENTS
               BAS2ASI TEST.BAS NOCOMMENTS NOWARNINGS NOERRORS

     Description:  BAS2ASI expects filename.BAS to be a GWBASIC program

                                     Page - 153


     that has been stored in ASCII format.  It will convert this program to ASIC
     format and store it in a file with the same file name but with an
     extension of '.ASI'.  Based on the file you specify, BAS2ASI will use the
     following files:

             filename.BAS    <--input GWBASIC file name
             filename.ASI    <--output ASIC file name
             filename.LBL    <--temporary file created/deleted by BAS2ASI
             filename.TMP    <--temporary file created/deleted by BAS2ASI


                                  NOCOMMENTS Option

     By default, BAS2ASI includes both the original sources lines as comments,
     and the converted statements in the ".ASI" file.  The NOCOMMENTS will
     suppress these comments, but will not suppress the conversion of REM
     statements in the source program.  For example,

          Original .BAS file       Converted .ASI File (.ASI with NOCOMMENTS)
          ---------------------    ------------------- -----------------
          10 REM SAMPLE PROGRAM    REM SAMPLE PROGRAM  REM SAMPLE PROGRAM
          20 X=Y*Z                 REM 20 X=Y*Z        X@ = Y@ * Z@
                                   X@ = Y@ * Z@


                                   NOERRORS Option

     BAS2ASI will generate error messages whenever it cannot convert a
     statement.  Once you become familiar with how BAS2ASI works, you may know
     which statements won't convert and thus not need these messages.  This
     option let's you suppress the generation of these messages.  It will be up
     to you to determine if ASIC didn't convert some statements.


                                  NOWARNINGS Option

     BAS2ASI will generate warning messages whenever it converts a statement
     partially.  Usually these are generated when the converted statement works
     slightly differently than the original GWBASIC statement.   Once you become
     familiar with how BAS2ASI works, you may know which statements won't
     convert fully and thus not need these messages.  This option let's you
     suppress the generation of these messages.  It will be up to you to
     determine if ASIC didn't fully convert some statements.

                                   Conversion Tips

     Although BAS2ASI makes a valiant attempt to convert your code as optimally
     as it can, it will never be as efficient as a good human programmer
     manually converting a program.  This section describes things you can do
     both before and after converting a program to optimize performance.




                                     Page - 154


                                 Pre-conversion Tips

     1)  The default data type in GWBASIC is single precision floating point.
     BAS2ASI will convert this to an ASIC Decimal data type (which is the least
     efficient ASIC data type).  If you know that the variable will only contain
     an integer value in the range of +/-32767, change the data type in the BAS
     file to integer.  If you know that all numeric values will fit in this
     range, add a DEFINT A-Z statement at the start of the BAS file.  BAS2ASI
     will then store these variables in ASIC integer variables which are much
     more efficient.

     2)  String constants longer than 80 characters will be truncated to 80
     characters by BAS2ASI.  You may wish to consider splitting long constants
     to 80 character lengths before converting the program.

     3)  BAS2ASI has problems converting IF statements with multiple statements
     embedded. For example (IF A=B THEN PRINT A:PRINT B ELSE PRINT C:PRINT D)
     BAS2ASI will flag these as syntax errors even though they are legal in
     GWBASIC.  You will have to convert this form of the IF statement manually.
     This form is legal (IF A=B THEN PRINT A ELSE PRINT B).

     3)   DEFINT/DEFSNG/DEFDBL/DEFSTR can be used in GWBasic to redefine a
     variable on the fly.  BAS2ASI will accept this, but you could experience
     problems, since the DEFXXX is interpreted at conversion time once by
     BAS2ASI, but is re-interpreted on the fly by GWBASIC.  Move all of your
     DEFXXX's to the top of the program to be safe.

                                Post-conversion tips

     After you convert your program, you may see a number of warnings and errors
     in the program which require your attention.

     Error Messages

     If a statement is not supported in ASIC, BAS2ASI will display a statement
     such as "*** 'xxxx' statement is not supported" (where 'xxxx' is the name
     of a GWBASIC statement).   This indicates a statement or function for which
     there is not direct equivalent in ASIC.  You will have to write your own
     code in ASIC to accomplish equivalent functionality.

     Warning Messages

     Sometimes, BAS2ASI will write warnings to your source file.  These are
     prefixed with a "*" character.  Usually, this happens when ASIC supports
     the GWBASIC statement, but not one of the parameters on the statement.
     These
     are also written when the ASIC function operates differently.

     Syntax Errors

     These occur when BAS2ASI finds a statement that it believes is not in the
     correct GWBASIC format.  Correct the statement to the proper GWBASIC syntax
     and try converting again.

                                     Page - 155



     Statement Optimization

     If, after you address the above messages, you may find that the converted
     program performance is not as fast as you would like, you can probably
     still optimize the converted code further.  A major area for improvement
     can be obtained by changing the data type of ASIC temp variables.  Consider
     the following sample converted file:

            REM 1  DEFINT A-Z

            REM 10 X=Y*Z*Q
            ASIC0@ = Y * Z
            X = ASIC0@ * Q

     BAS2ASI generates temporary work variables when simplifying complex GWBASIC
     expressions to ASIC format.  These temporary variables are always defined
     as decimal data types.  However, in the above example, it is clear from the
     DEFINT statement, that all variables are integers and that we don't need
     the extra precision of the decimal data type.  We could improve performance
     slightly by changing ASIC0@ to ASIC0.  This is especially true if this
     calculation were performed many times inside a FOR/NEXT loop.

                                   BAS2ASI LIMITS

     This section describes BAS2ASI conversion limits.  In addition to the
     Warnings and Errors described above, the following limits are in effect.

     1)  Any "." characters in variable names are converted to "_".  For
     example,"
          MY.NAME" is translated to "MY_NAME".  This is because ASIC does not
          support "." characters in a variable name.

     2)  Single and double precision numbers are converted to the ASIC decimal
          data type.  Thus,
               APPLE   converts to APPLE@
               ORANGE! converts to ORANGE@
               PEAR#   converts to PEAR@
               GRAPE%  converts to GRAPE

     3) WHILE/WEND and IF/THEN/ELSE statements can be nested 25 levels deep.

     4) NEXT statements must include the counter variable name (i.e., "NEXT I",
     not "NEXT").

     5) Statements that BAS2ASI cannot convert fully will be prefixed with "*".
     This will cause a syntax error if you compile in ASIC.  After you correct
     the statement, remove the leading "*".

     6) CLOSE Statements in ASIC may only contain integer constants.  Other
     valid GWBASIC constructs are flagged as errors.

     7) String constants on DATA statements must always be enclosed in quotes.

                                     Page - 156



     8) INPUT# file numbers should be in the range 1-3. ASIC will not handle
     other file numbers.  BAS2ASI converts each variable on an INPUT# statement
     into separate INPUT# statements.

     9) LOCATE statements without a ROW or COL specified are flagged as syntax
     errors.

     10) The filenum parameter of OPEN, INPUT#, PRINT# and close must be a
     constant, or a syntax error will be generated.

     11)  Arrays are limited to 3 dimensions.  Up to 25 arrays per program can
     be used. Arrays must be DIM'd before use.

     12)  If/Then/Else statements can be nested up to 25 levels deep







































                                     Page - 157


                                       A S I C

                                     Chapter 12

                                   Error Messages


     This chapter contains compiler messages, run-time error messages, and File
     I/O Error Codes.


                                   COMPILER ERRORS

          These messages indicate errors in your source program.  Those which
     begin with "** E" indicate "fatal" errors, which prevent ASIC from
     successfully compiling your program.  Warnings begin with "* W" and
     indicate possible errors and informative messages which will not prevent
     ASIC from generating an executable ".COM" or ".EXE" file.


                                    FATAL ERRORS

     ** E001 **  File Extensions must be '.ASI', '.PRJ' or omitted

     ASIC requires source programs to have the extension ".ASI".  Rename your
     source file with the DOS "RENAME" command to the name "file.ASI", where
     "file" is your source program name.  Then resubmit the compile.
     The ".ASI" extension is the only valid one for the ASIC Editor, but the
     command line compiler will also accept a ".PRJ" extension.

     ** E002 ** File Name specified is too long

     The source file may be identified by a file name up to 124 characters long
     including disk drive specifiers and sub directory names.  Move the source
     program to a directory which may be specified within this length.

     ** E003 ** Error Opening File:  xxxxxxxx.xxx

     The file indicated by "xxxxxxxx.xxx" could not be opened by ASIC.  This
     error can be issued when ASIC attempts to read your source file, or when it
     writes any one of the possible output files (".COM", ".EXE", ".LST", or
     ".SYM").  If indicated file is your source program name, verify the
     spelling, and either make sure it is in the same directory as ASIC, or
     specify the full path name for the file.  If the indicated file is an
     output file, the error is usually a result of a write protect tab on the
     diskette or insufficient disk space.

     ** E004 ** DIM Statements must precede all others except REMs

     In ASIC, DIM statements must appear before all other statement types,
     except REM or SUB statements (or blank lines).

     ** E005 ** Too many characters in source line

                                     Page - 158



     Source program lines in ASIC are limited to 120 characters.  Change the
     indicated source line, so that it fits within this limit.

     ** E006 ** Unmatched Quote ('"') in source line

     A string constant was found with either no opening or closing quote mark.
     Quotation marks must be matched in pairs within source lines.

     ** E007 ** Token in source line > 82 characters long

     Individual tokens in ASIC are limited to 82 characters in length,
     regardless of type.  A token is a group of letters and/or numbers delimited
     on either side by a space or math symbol.  Example, even though string
     constants are limited to 80 characters, ASIC considers the "token" to
     include the quotation marks.  In this case, however, ASIC detected a token
     longer than the longest possible token, the string constant.  Check for
     "tokens" or "words" more than 82 characters long in the indicated source
     line.

     ** E008 ** More than 30 tokens in source line

     Since all ASIC statements require less than 30 tokens, ASIC will flag any
     statement which contains more than this number.  A token is a group of
     letters and/or numbers delimited on either side by a space or math symbol.

     ** E009 ** Keyword Unknown:  xxxxxxxxx

     ASIC detected the symbol indicated by "xxxxxxxx" in your source line, but
     it was not a valid variable name, constant, label, or ASIC Function Name.

     ** E010 ** Symbol Table Space Exhausted

     The symbol table is used by ASIC to keep track of your variables, constants
     and labels.  It is also used to hold information used in FOR/NEXT
     processing, and internal system subroutine generation.  Reduce the number
     of LABELS, VARIABLE NAMES, or CONSTANTS in your program, and recompile.

     ** E011 ** Symbol Incomplete Reference Space Exhausted

     This table is a sister table to the Symbol Table, it contains references to
     LABEL type symbols which have been defined in the symbol table.  Try to
     reduce the number of references made to LABEL symbols within the program
     and recompile.

     ** E012 ** No keywords in source line

     Every ASIC source program line must contain an ASIC keyword (eg. "PRINT",
     "=", "GOSUB", etc).

     ** E013 ** Syntax Error



                                     Page - 159


     The "catch-all" error for ASIC.  This error is usually issued when ASIC has
     identified an error in the parameters for an ASIC keyword.  The best way to
     find this error is to refer to the entry in the Keyword Reference (chapter
     7) for that particular keyword.

     ** E014 ** Undefined Symbol:  xxxxxx

     ASIC detected a LABEL "xxxxxx" which was referenced, but never defined in
     the program.  A label is considered to be defined when it is the first
     token on the source line.  A reference to a label occurs when a label name
     appears elsewhere in the source statement

          Example:           PRINTIT:   PRINT "hello"      <---Defined
                                   GOTO PRINTIT:      <--Referenced

     ** E015 ** Compiled Code Exceeds 64k-Can't fit in .COM file

     Your source program is too large to fit in the .COM file format.  Recompile
     using the "Build EXE" option.  See Chapter 5 for more information.

     ** E016 ** Integer Constant Not in range +32767 to -32767

     The above range of numbers is the maximum which can be contained in integer
     format in ASIC.  Reduce the constant so that it falls within the specified
     range.

     ** E017 ** Duplicate Label:    xxxxxx

     The indicated label "xxxxxx" was defined more than once in the program.
     Reduce the multiple definitions to a single definition and then recompile.

     ** E018 ** Second FOR defined for variable with no intervening NEXT

     FOR/NEXT Statements cannot be nested with the same variable name.

               VALID                              INVALID

               FOR I=1 TO 10                      FOR I=1 TO 10
                    FOR J=1 TO 20                      FOR I=1 TO 20
                    NEXT J                             NEXT I
               NEXT I                             NEXT I


     ** E019 ** For/Next Table Space Exhausted

     An unlimited of FOR/NEXT statements can exist, however, they can be
     "nested" to a maximum depth of 25.

     ** E020 ** NEXT without FOR

     A NEXT statement was found, however it was not preceded in the source
     program with a matching FOR statement.


                                     Page - 160


     ** E021 ** FOR without NEXT at Source Line NNNNN

     The indicated source line NNNNN contains a FOR statement, for which no NEXT
     statement was ever found.

     ** E022 ** Invalid Option:  x

     An invalid compile option was specified.  Review Chapter 5 for a list of
     valid compile options.

     ** E023 ** More than 63000 bytes in Data Segment

     An ASIC program can be up to 64k bytes in size.  Of this total, 63000 bytes
     can contain program variables and constants, leaving at least 1k for
     program code.  Reduce the number of variables and constants in your
     program.

     ** E024 ** Too many arrays defined

     A single ASIC source program can contain up to 25 arrays.

     ** E025 ** Re-DIMension of previously DIMensioned variable

     Only one DIM statement can be specified per array name.

     ** E026 ** Invalid subscript on Array

     A subscript was found which is not valid.  Either ASIC expected more or
     less subscripts than were present, or ASIC detected a subscript which was
     itself an array.  Subscripts on arrays may only be non-array variables
     and/or integer constants.

     ** E030 ** Code Segment Memory Exhausted

     ASIC will attempt to allocate 64k of memory to use a work space to hold the
     code generated by your program statements.  This message indicates that the
     amount of memory it was able to allocate was not sufficient to hold the
     code generated by the program you are trying to compile.

     ** E031 ** Data Segment Memory Exhausted

     ASIC will attempt to allocate 64k of memory to use a work space to hold the
     data segment for your program.  This message indicates that the amount of
     memory it was able to allocate was not sufficient to hold the data
     generated by the program you are trying to compile.

     ** E032 ** Insufficient Memory to Run ASIC

     You don't have enough memory to run ASIC.  If you have any TSRs loaded, try
     removing them and re-compiling.

     ** E033 ** Edit Buffer Memory Allocation Failed


                                     Page - 161


     ASIC attempted to allocate memory for the edit buffer in the integrated
     environment, but was unable to.  If you have any TSRs loaded, remove them
     from memory, and try again.

     ** E034 ** DATA Statements Must Precede All Except DIMs or REMs

     If you wish to use the DATA statement in ASIC, you must place them all at
     the beginning of your program following any SUB DIM and/or REM statements
     (or blank lines).

     ** E035 ** Requires 32 Bit Math--Recompile W/Math Option

     The compiler found a statement containing long (32bit) integer variables or
     constants.  You must compile with the Extended Math Option turned on to be
     able to use long integer math.  Turn on the "Extended Math" Option from the
     Compile Menu in the ASIC Integrated Environment, and recompile the program.
     If you are compiling from the MS DOS command line, recompile using switch
     "E".

     ** E036 ** Error Allocating Debugger Screen Memory

     ASIC was unable to allocate memory to save the screen output from your
     programs when you run your program in debugging mode in the ASIC integrated
     environment.  You could try removing some TSRs from your AUTOEXEC.BAT file.
     Then try running ASIC again.

     ** E037 ** IF Statements Nested Deeper Than 25 Levels

     An unlimited number of block IF statements may be used in your program,
     however, they may be nested to a maximum depth of 25 levels.  See the IF
     statement documentation in Chapter 7 for more information.

     ** E038 ** ELSE Statement Without Preceding IF Statement.

     ASIC found an ELSE statement but did not find a preceding block IF
     statement.  See the IF Statement documentation in Chapter 7 for more
     information.

     ** E039 ** ENDIF Statement Without Preceding IF Statement.

     ASIC found an ENDIF statement with no preceding matching IF statement.  See
     the IF statement documentation in Chapter 7 for more information.

     ** E040 ** Block IF Statement Without Matching ENDIF Statement.

     When using the block IF format of the IF statement, you must always specify
     a matching ENDIF statement.  See the IF Statement documentation in Chapter
     7 for more information.

     ** E041 ** WHILE Statements Nested Deeper Than 25 Levels




                                     Page - 162


     An unlimited number of WHILE statements may be used in your program,
     however, they may be nested to a maximum depth of 25 levels.  See the WHILE
     statement in Chapter 7 for more information.

     ** E042 ** WEND Statement Without Preceding WHILE Statement

     ASIC found a WEND statement with no preceding matching WHILE statement.
     See the WHILE statement documentation in Chapter 7 for more information.

     ** E043 ** WHILE Statement Without Matching WEND Statement

     Each WHILE statement must be followed by a matching WEND statement.  See
     the WHILE statement documentation in Chapter 7 for more information.

     ** E044 ** This statement format is only valid when producing OBJ files.

     You used a format of a statement which does not make sense with the current
     compiler option.  For example, you specified "CALL SUB" when compiling with
     the B/EXE or B/COM option.  This is invalid, since CALL SUB will generate a
     reference for the linker to resolve the SUB procedure name.  ASIC will not
     resolve the SUB reference when using the B/COM or B/EXE option, since no
     OBJ file is produced with these options.  Recompile with the B/OBJ option
     (select the OBJ option in the integrated environment).

     ** E047 ** Requires Decimal Math--Recompile w/DEC Option

     Your program contains a statement containing a decimal variable or constant
     (eg, A@ or 1.234).  To use decimal numbers, you must turn on the "Decimal
     Math" option from the "Compile" menu, or, if you are compiling from the
     command line, by specifying the command line option "DEC".  Turn on this
     option, and recompile your program.

     ** E048 ** 999999999999.99999 Is Max Constant Size

     You specified a decimal constant in your program which exceeds the maximum
     size that ASIC can handle.  Modify your program until the constant is
     within +/-999,999,999,999.99999 and recompile your program.

     ** E050 ** SUB statements must be the first line of a source file

     You included a SUB statement in a program, but it is not located at the
     beginning of the source file.  Move the SUB statement to the very first
     line of the source program.

     ** E051 ** Must compile with OBJ compile option when using SUB

     Your program contains a SUB statement.  When compiling SUB modules, you
     must use the "Object Output File" compile option.  Select this option from
     the advanced compile menu in the editor.  If compiling from the command
     line, specify "B/OBJ".

     ** E052 ** Turn off DEBUG option when compiling SUB programs


                                     Page - 163


     Your program contains a SUB statement.  You cannot generate Debugging Code
     for SUB modules.  Turn off the "Debugging Code" compile option and
     recompile the program.


                                 NON-FATAL WARNINGS

     * W002 * Printer Not Ready - 'P' Option Ignored

     You selected the "Printer" option, but ASIC was not able to access the
     printer.  Make sure the printer is online before compiling with the 'P'
     option.

     * W004 * Edit Buffer Full--File Truncated

     While loading a file, the edit buffer filled before ASIC reached end-of-
     file.  The file is truncated in memory.  IF YOU SAVE THE FILE AFTER
     RECEIVING THIS MESSAGE, PART OF THE FILE WILL BE LOST ON DISK.  IT IS
     RECOMMENDED THAT YOU EITHER EXIT ASIC IMMEDIATELY, OR THAT YOU SAVE THE
     TRUNCATED FILE UNDER A NEW NAME SO THAT THE ORIGINAL FILE IS NOT DAMAGED.

     * W005 *  Edit Buffer Full

     ASIC issues this message when the edit buffer is full and you attempt to
     insert a line.  Delete some unnecessary source lines to create space in the
     edit buffer.

     * W006 * Source/Dest of Block Copy/Move May Not Overlap

     You attempted to move or copy a block of lines to a destination line which
     was within the source block of lines.  Execution of this block move/copy
     would result in an endless series of copies or moves.  Move the cursor
     outside of the highlighted block of lines, and try again.

     * W007 * Source Program Modified.  Recompile? (Y/N)

     You selected the RUN or TRACE option of ASIC.  ASIC has noticed that you
     have modified the source.  You should answer "Y" here to cause ASIC to
     recompile your program before running it.  If you instead answer "N", ASIC
     will execute the existing copy of the compiled program, which will not
     contain your latest changes.

     * W009 * File has been modified.  Save File Now? (Y/N)

     You have told ASIC to exit back to DOS, but the edit buffer has been
     modified.  You should answer "Y" so that ASIC will save your changes back
     to disk.  If you answer "N" here, any changes you have made to your program
     since the last SAVE command will be lost.

     * W010 * Too Much Debugging Info-Truncating

     ASIC could not handle all of the debugging information it found.  This
     error should not occur.

                                     Page - 164



     * W011 * Variable Not Found

     During the processing of a Watch, Unwatch, or Modify Command, you specified
     a variable name which ASIC could not find in the debugging information.
     Checking your spelling for possible errors.  Also, verify that you have
     compiled your program with the Debugging compiler option turned ON.

     * W012 * Maximum Number of Variables Are Being Watched

     You are already "watching" the maximum number of variables that this
     version of ASIC supports.  "Unwatch" one of the variables in the watch
     window.  This will allow you to "Watch" a new one.

     * W013 * There Are No Variables Being Watched

     You selected the "Unwatch" command.  However, there are no variables in the
     watch window to "Unwatch".  Before this command may be used, you must first
     have added a variable to the Watch window using the "Watch variable"
     command.

     * W014 * Unable to Load/Run Program

     When ASIC attempted to load and run either the compiler or your program it
     detected an error.  This is due to one of two reasons.  First, ASIC could
     not find the program on disk.  If compiling, make sure that the ASICC.EXE
     file is in the same directory as the ASIC.EXE file, and make that directory
     current.  The second reason that you might get this error is that there may
     be insufficient memory available on your PC.  In this case, you either need
     to free up more memory (by removing TSRs etc), or you could execute your
     program or the compiler from the DOS command line.  For more information on
     compiling from the command line, see Chapter 5--Stand-alone Compiler
     Options.

     * W015 * Can't Set Breakpoint--No Code Generated For That Source Line

     You attempted to set a breakpoint and either 1) You haven't compiled with
     the Debugging Compiler Option turned on, or 2)  You have tried to set a
     breakpoint on a line which did not generate any object code.  Thus,
     breakpoints cannot be set on REM or DATA statements, for example.  If you
     are sure that you have compiled with the above option turned on, then try
     setting the breakpoint on another nearby statement.

     * W018 * Your Program Must Be Running To Use This Function

     You selected a function which is only operable when you are running a
     program (which was compiled with the debugging compiler option turned on).
     After your program terminates, this function is not available.

     * W019 * Function Unavailable Until You Terminate Your Program

     You selected a function while your program was running in debugging mode.
     Before you can execute this function you must either Abort your program, or

                                     Page - 165


     allow it to Run until normal termination.  Both the Run and the Abort
     Options are available on the "Run" Menu.

     * W020 * Invalid Debug (.DBG) File Format

     ASIC attempted to access the symbolic debugging information file created by
     the compiler for your program.  It was able to locate the file, but
     detected an error in the format while reading it.  Make sure that the
     version number of both the ASIC Integrated Editor and the ASIC Compiler are
     the same.  The version number is displayed on the top line of the editor
     screen, following the word "ASIC".  It is also displayed on the compiler
     status screen while a compile is executing.

     * W021 * Maximum Number of Breakpoints Already Set

     You have attempted to set another breakpoint, but the maximum number that
     this version of ASIC can support are already in use.  Remove one of the
     existing breakpoints you have set.  This will free one up for your use
     elsewhere.

     * W022 * Can't Open ASIC.IDX File

     You requested online help for an ASIC keyword.  This function requires a
     file called "ASIC.IDX" provided with your ASIC package, and ASIC could not
     find this file in the current disk directory.  Copy this file from your
     ASIC package to the directory in which you are running ASIC and try again.

     * W023 * Can't Open ASIC.DOC File

     You requested online help for an ASIC keyword or menu option.  This
     function requires a file called "ASIC.DOC" provided with your ASIC package,
     and ASIC could not find this file in the current disk directory.  Copy this
     file from your ASIC package to the directory in which you are running ASIC
     and try again.

     * W024 * Can't Open ASICM.IDX File

     You requested online help for an ASIC menu option.  This function requires
     a file called "ASICM.IDX" which was provided with your ASIC package, and
     ASIC could not find this file in the current disk directory.  Copy this
     file from your ASIC package to the directory in which you are running ASIC
     and try again.

     * W025 * No Help Available For Selected Item

     There is no online help available for the item you selected.  The
     information should be available in the ASIC Manual.

     * W026 * Unable To Write ASIC.CFG File

     You told ASIC to save your current Integrated Environment Options.  ASIC
     attempted to do so, but was not able to.  Your options were not saved to
     disk.  This is usually caused by one of two things: 1)  The disk is full,

                                     Page - 166


     or 2)  The disk is write-protected.  If the disk is full, delete some
     unneeded files and try again.  If the disk is write-protected, remove the
     write-protect tab from the disk and try again.

     * W027 * Debugger Can't Fully Save User Screen--Insufficient Memory

     ASIC was not able to allocate enough memory to save the screen output from
     your program while it was running in debugging mode in the integrated
     environment.  As a result, the screen displays may become garbled.  You
     should normally only see this message when your program is using a high
     resolution EGA/VGA graphic mode on machines with very low memory, or you
     have many TSRs installed.  Either purchase more memory, go to a lesser
     graphics mode, remove some TSRs from the AUTOEXEC.BAT file, or run your
     program outside of the integrated environment.

     * W028 * Not Enough Memory To Build Full File List

     After you selected the Open or Save options from the File menu, ASIC
     attempted to build a list of existing file names in memory, but was unable
     to due to lack of memory.  Exit from the editor and try to free up more
     memory by removing TSR's, etc.

     * W029 * Out of Memory -- Allocating Debug Symbols

     The editor was trying to read the debugging information for your program,
     but was unable to allocate enough memory to store the information.  If you
     proceed, the Watch, Unwatch, Modify Variable, Trace, and Breakpoint
     commands may perform erratically.  Exit the editor and try to free up more
     memory by removing TSR's, etc.

     * W030 * Stack Size Must Be 16-32767

     You selected the Stack Option off of the Advanced Options Menu, and entered
     a stack size that is too small or too large.  Your entry was ignored--the
     stack size was not updated.

     * W031 * Unable To Save Program Options

     ASIC attempted to save program compile options to disk, but was not able
     to.  This is usually caused by a disk that is full or has the write protect
     tab set.

     * W032 * Unable to run COMMAND.COM

     ASIC was unable to locate the COMMAND.COM file.  Because of this, it was
     unable to complete your request.


                                   RUN TIME ERRORS

     Divide Overflow

     This message indicates that your program attempted to divide by zero.

                                     Page - 167




                              SYSTEM ERROR CODE VALUES

     After most commands which access the disk, ASIC sets a special "ERROR"
     variable to indicate success or failure of that command.  After you execute
     one of these commands, you can reference this variable as a regular
     variable in your program, to determine the outcome of the command(eg. "IF
     ERROR = 000 THEN OKAY:").

     ERROR Codes Set by BLOAD

     000       No Error
     002       File Not Found
     003       Path Not Found or File Doesn't Exist
     004       File Not Found
     005       File Access Denied
     006-255   Read Past End of File

     ERROR Codes Set by BSAVE

     000       No Error
     002       File Not Found
     004       File Not Found
     005       File Access Denied
     006-255   Disk Full

     ERROR Codes Set by CALL

     000-254   Return Code from Program (Zero If Not Set by User Program)
     255       Error Loading/Running Program

     ERROR Codes Set by CHDIR

     000       No Error
     003       Path Not Found

     ERROR Codes Set by CLOSE

     000       No Error
     006       Invalid Handle
     095       Cannot Close File -- File is not Open

     ERROR Codes Set by FILEPOS

     000       No Error
     001       Invalid Function Number
     006       Invalid Handle
     098       File mode not Random or Append

     ERROR Codes Set by FIND

     000       No Error

                                     Page - 168


     002       File Not Found
     018       No More Files Match Search Criteria

     ERROR Codes Set by GETDIR

     000       No Error
     015       Invalid Disk Drive Specification

     ERROR Codes Set by INPUT (when using ";" option)

     000       No Error
     001       Invalid Input

     ERROR Codes Set by INPUT#

     000       No Error
     005       Read Access Denied
     006       Invalid File Handle
     096       Input String Truncated at 80 characters
               (this error code is not set when you specify NONULL)
     098       File Not Open for Input or Random Modes
     099       End of File

     ERROR Codes Set by KILL

     000       No Error
     002       File Not Found
     005       Access Denied

     ERROR Codes Set by MKDIR

     000       No Error
     003       Path Not Found
     005       Access Denied

     ERROR Codes Set by NAME

     000       No Error
     002       File Not Found
     003       Path Not Found or File Doesn't Exist
     005       Access Denied
     017       Not Same Disk Drive

     ERROR Codes Set by OPEN --- Mode Input

     000       No Error
     002       File Not Found
     004       File Not Found
     005       File Access Denied
     254       File Number Already in Use

     ERROR Codes Set by OPEN --- Mode Output, Append, or Random


                                     Page - 169


     000       No Error
     001       Invalid Append Function
     003       Path Not Found
     004       No File Handle Available
     005       File Access Denied
     006       Invalid Append Handle
     254       File Number Already in Use

     ERROR Codes Set by PRINT#

     000       No Error
     005       File Access Denied
     006       Invalid File Handle
     097       File Not Open for Output, Append, or Random Modes
     255       Disk Full

     ERROR Codes Set by RMDIR

     000       No Error
     003       Path Not Found
     005       Access Denied
     006       Can't Delete Current Directory
     016       Can't Delete Current Directory

     ERROR Codes Set by RUN

     000-254   Return Code from Program (Zero If Not Set by User Program)
     255       Error Loading/Running Program

     ERROR Codes Set by DECIMAL Math Routines

     000       No Error
     001       Division By Zero





















                                     Page - 170